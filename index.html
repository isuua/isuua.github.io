<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>éŸ³é¢‘å½•éŸ³ Â· æ”¯æŒè®¾å¤‡é€‰æ‹©ï¼ˆå…¼å®¹ iPhoneï¼‰</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #1a1a1a;
      color: #eee;
      padding: 20px;
      margin: 0;
    }
    h2 { text-align: center; margin-bottom: 20px; }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center;
      align-items: center;
    }
    button, select {
      padding: 10px 12px;
      border: none;
      border-radius: 6px;
      background: #444;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    select {
      background: #333;
      min-width: 180px;
    }
    button:hover { background: #555; }
    button:disabled { background: #333; color: #777; cursor: not-allowed; }
    button.active { background: #1e88e5; }
    button.danger { background: #d32f2f; }
    canvas {
      width: 100%;
      height: 250px;
      background: #000;
      border-radius: 8px;
      display: block;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    input[type="range"] {
      width: 120px;
    }
    #log {
      color: #ffcc00;
      font-size: 12px;
      margin-top: 10px;
      min-height: 20px;
      text-align: center;
    }
    .device-selectors {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <h2>ğŸ¤ éŸ³é¢‘å½•éŸ³ Â· è®¾å¤‡é€‰æ‹©ï¼ˆå…¼å®¹ iPhoneï¼‰</h2>

  <div class="device-selectors">
    <select id="inputSelect" disabled>
      <option value="">-- é€‰æ‹©éº¦å…‹é£ --</option>
    </select>
    <select id="outputSelect" disabled>
      <option value="">-- é€‰æ‹©æ‰¬å£°å™¨ --</option>
    </select>
  </div>

  <div class="controls">
    <button id="startBtn">å¼€å§‹éŸ³é¢‘</button>
    <button id="stopBtn" disabled class="danger">å…³é—­éŸ³é¢‘</button>
    <button id="filterBtn" disabled>å¯ç”¨æ»¤æ³¢</button>
    <button id="recordBtn" disabled>å¼€å§‹å½•éŸ³</button>
    
    <div class="slider-container">
      <label>äººå£°å¢ç›Š:</label>
      <input type="range" id="gainSlider" min="0" max="300" value="150" />
      <span id="gainValue">1.5x</span>
    </div>
  </div>

  <canvas id="fftCanvas"></canvas>
  <div id="log">è¯·é€šè¿‡ HTTPS è®¿é—®ï¼ˆå¦‚ GitHub Pagesï¼‰</div>

  <script>
    // ================= å…¨å±€çŠ¶æ€ =================
    let audioContext = null;
    let sourceNode = null;
    let stream = null;
    let analyser = null;
    let isFiltering = false;
    let isRecording = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let filters = [];
    let currentInputDeviceId = null;

    const notchFreqs = [50, 100, 150, 200, 250];
    const Q = 35;

    // ================= DOM =================
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const filterBtn = document.getElementById('filterBtn');
    const recordBtn = document.getElementById('recordBtn');
    const gainSlider = document.getElementById('gainSlider');
    const gainValue = document.getElementById('gainValue');
    const canvas = document.getElementById('fftCanvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const inputSelect = document.getElementById('inputSelect');
    const outputSelect = document.getElementById('outputSelect');

    function log(msg) {
      console.log(msg);
      logEl.textContent = msg;
    }

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ================= å®‰å…¨æ£€æŸ¥ mediaDevices =================
    const hasMediaDevices = navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function';

    // ================= æšä¸¾è®¾å¤‡ï¼ˆå®‰å…¨è°ƒç”¨ï¼‰=================
    async function enumerateDevices() {
      if (!hasMediaDevices) {
        log("âš ï¸ å½“å‰ç¯å¢ƒä¸æ”¯æŒè®¾å¤‡æšä¸¾");
        return;
      }

      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(d => d.kind === 'audioinput');
        const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

        // æ¸…ç©ºé€‰æ‹©æ¡†
        inputSelect.innerHTML = '<option value="">-- é€‰æ‹©éº¦å…‹é£ --</option>';
        outputSelect.innerHTML = '<option value="">-- é€‰æ‹©æ‰¬å£°å™¨ --</option>';

        // å¡«å……è¾“å…¥è®¾å¤‡
        audioInputs.forEach(device => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          // iOS é€šå¸¸è¿”å›ç©º labelï¼Œç”¨é»˜è®¤å
          option.text = device.label || `éº¦å…‹é£ ${inputSelect.children.length}`;
          inputSelect.appendChild(option);
        });

        // å¡«å……è¾“å‡ºè®¾å¤‡ï¼ˆæ³¨æ„ï¼šiOS ä¸æ”¯æŒ setSinkIdï¼‰
        audioOutputs.forEach(device => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.text = device.label || `æ‰¬å£°å™¨ ${outputSelect.children.length}`;
          outputSelect.appendChild(option);
        });

        // å¯ç”¨é€‰æ‹©æ¡†ï¼ˆä»…å½“æœ‰è®¾å¤‡æ—¶ï¼‰
        inputSelect.disabled = audioInputs.length <= 1;
        outputSelect.disabled = audioOutputs.length === 0 || !('setSinkId' in HTMLAudioElement.prototype);

        // é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ªè¾“å…¥è®¾å¤‡
        if (audioInputs.length > 0) {
          currentInputDeviceId = audioInputs[0].deviceId;
          inputSelect.value = currentInputDeviceId;
        }

      } catch (err) {
        log("âš ï¸ è®¾å¤‡æšä¸¾å¤±è´¥: " + (err.message || err));
      }
    }

    // ================= æ„å»ºéŸ³é¢‘å›¾ =================
    function buildAudioGraph(enableFilter) {
      filters.forEach(f => f.disconnect());
      filters = [];

      analyser = audioContext.createAnalyser();
      analyser.fftSize = 1024;

      let currentNode = sourceNode;

      if (enableFilter) {
        for (const freq of notchFreqs) {
          const nf = audioContext.createBiquadFilter();
          nf.type = 'notch';
          nf.frequency.value = freq;
          nf.Q.value = Q;
          currentNode.connect(nf);
          currentNode = nf;
          filters.push(nf);
        }

        const hp = audioContext.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.value = 40;
        currentNode.connect(hp);
        currentNode = hp;
        filters.push(hp);

        const bp = audioContext.createBiquadFilter();
        bp.type = 'peaking';
        bp.frequency.value = 1850;
        bp.gain.value = parseFloat(gainSlider.value) / 100;
        bp.Q.value = 0.8;
        currentNode.connect(bp);
        currentNode = bp;
        filters.push(bp);
      }

      currentNode.connect(analyser);
      analyser.connect(audioContext.destination);
    }

    // ================= åœæ­¢æ‰€æœ‰éŸ³é¢‘èµ„æº =================
    async function stopAllAudio() {
      if (isRecording) {
        await stopRecording(false);
      }

      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }

      if (audioContext) {
        await audioContext.close();
        audioContext = null;
      }

      sourceNode = null;
      analyser = null;
      filters = [];
      isFiltering = false;

      startBtn.disabled = false;
      stopBtn.disabled = true;
      filterBtn.disabled = true;
      filterBtn.classList.remove('active');
      recordBtn.disabled = true;
      recordBtn.classList.remove('active');
      inputSelect.disabled = true;
      outputSelect.disabled = true;
      log("éŸ³é¢‘å·²å…³é—­");
    }

    // ================= åœæ­¢å½•éŸ³ =================
    async function stopRecording(save = true) {
      if (!isRecording) return;
      isRecording = false;

      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      if (save && recordedChunks.length > 0) {
        const now = new Date();
        const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
        let filename = `recording_${timestamp}.m4a`;
        let mimeType = 'audio/mp4';

        if (!MediaRecorder.isTypeSupported('audio/mp4')) {
          if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
            mimeType = 'audio/webm;codecs=opus';
            filename = filename.replace('.m4a', '.webm');
          } else {
            mimeType = 'audio/webm';
            filename = filename.replace('.m4a', '.webm');
          }
        }

        const blob = new Blob(recordedChunks, { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        log(`âœ… å½•éŸ³å·²ä¿å­˜: ${filename}`);
      }

      recordedChunks = [];
      mediaRecorder = null;
      recordBtn.textContent = "å¼€å§‹å½•éŸ³";
      recordBtn.classList.remove('active');
    }

    // ================= å¯åŠ¨éŸ³é¢‘ï¼ˆç”±ç”¨æˆ·ç‚¹å‡»è§¦å‘ï¼‰=================
    startBtn.onclick = async () => {
      if (!hasMediaDevices) {
        log("âŒ æµè§ˆå™¨ä¸æ”¯æŒ getUserMedia");
        alert("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½ã€‚");
        return;
      }

      try {
        log("æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™...");

        const constraints = {
          audio: {
            deviceId: currentInputDeviceId ? { exact: currentInputDeviceId } : undefined,
            sampleRate: 44100,
            channelCount: 1,
            echoCancellation: true,
            noiseSuppression: true
          }
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        sourceNode = audioContext.createMediaStreamSource(stream);

        buildAudioGraph(false);

        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        // å°è¯•è®¾ç½®è¾“å‡ºè®¾å¤‡ï¼ˆä»…æ”¯æŒçš„æµè§ˆå™¨ï¼‰
        if (outputSelect.value && 'setSinkId' in HTMLAudioElement.prototype) {
          try {
            await audioContext.destination.setSinkId(outputSelect.value);
          } catch (e) {
            log("âš ï¸ æ— æ³•åˆ‡æ¢è¾“å‡ºè®¾å¤‡: " + e.message);
          }
        }

        startBtn.disabled = true;
        startBtn.textContent = "âœ… éŸ³é¢‘è¿è¡Œä¸­";
        stopBtn.disabled = false;
        filterBtn.disabled = false;
        recordBtn.disabled = false;
        inputSelect.disabled = true; // å¼€å§‹åé”å®š
        outputSelect.disabled = !('setSinkId' in HTMLAudioElement.prototype);
        log("âœ… éº¦å…‹é£å·²å¯ç”¨");

        drawFFT();
      } catch (err) {
        const msg = err.message || err.name || 'æœªçŸ¥é”™è¯¯';
        log("âŒ æ— æ³•è®¿é—®éº¦å…‹é£: " + msg);
        alert("è¯·å…è®¸éº¦å…‹é£æƒé™ï¼Œå¹¶ç¡®ä¿é€šè¿‡ HTTPS è®¿é—®ã€‚");
      }
    };

    stopBtn.onclick = () => stopAllAudio();

    filterBtn.onclick = () => {
      isFiltering = !isFiltering;
      filterBtn.classList.toggle('active', isFiltering);
      filterBtn.textContent = isFiltering ? "å…³é—­æ»¤æ³¢" : "å¯ç”¨æ»¤æ³¢";
      if (audioContext) buildAudioGraph(isFiltering);
    };

    gainSlider.oninput = () => {
      const g = gainSlider.value / 100;
      gainValue.textContent = g.toFixed(1) + 'x';
      if (isFiltering && audioContext) {
        buildAudioGraph(true);
      }
    };

    // ================= è®¾å¤‡åˆ‡æ¢äº‹ä»¶ =================
    inputSelect.onchange = () => {
      currentInputDeviceId = inputSelect.value || null;
    };

    outputSelect.onchange = async () => {
      if (!audioContext || !('setSinkId' in HTMLAudioElement.prototype)) return;
      try {
        await audioContext.destination.setSinkId(outputSelect.value);
        log("ğŸ”Š è¾“å‡ºè®¾å¤‡å·²åˆ‡æ¢");
      } catch (err) {
        log("âŒ åˆ‡æ¢è¾“å‡ºå¤±è´¥: " + err.message);
      }
    };

    // ================= å¼€å§‹å½•éŸ³ =================
    recordBtn.onclick = async () => {
      if (isRecording) {
        await stopRecording(true);
        return;
      }

      try {
        let mimeType = 'audio/mp4';
        if (!MediaRecorder.isTypeSupported('audio/mp4')) {
          if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
            mimeType = 'audio/webm;codecs=opus';
          } else {
            mimeType = 'audio/webm';
          }
        }
        recordedChunks = [];

        const dest = audioContext.createMediaStreamDestination();
        let recNode = sourceNode;

        if (isFiltering) {
          for (const freq of notchFreqs) {
            const nf = audioContext.createBiquadFilter();
            nf.type = 'notch';
            nf.frequency.value = freq;
            nf.Q.value = Q;
            recNode.connect(nf);
            recNode = nf;
          }
          const hp = audioContext.createBiquadFilter();
          hp.type = 'highpass';
          hp.frequency.value = 40;
          recNode.connect(hp);
          recNode = hp;

          const bp = audioContext.createBiquadFilter();
          bp.type = 'peaking';
          bp.frequency.value = 1850; 
          bp.gain.value = parseFloat(gainSlider.value) / 100;
          bp.Q.value = 0.8;
          recNode.connect(bp);
          recNode = bp;
        }
        recNode.connect(dest);

        mediaRecorder = new MediaRecorder(dest.stream, { mimeType });
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) recordedChunks.push(e.data);
        };
        mediaRecorder.onerror = (e) => {
          log("âš ï¸ å½•éŸ³é”™è¯¯: " + e.error);
          stopRecording(false);
        };

        mediaRecorder.start(100);
        isRecording = true;
        recordBtn.textContent = "åœæ­¢å½•éŸ³";
        recordBtn.classList.add('active');
        log("ğŸ™ï¸ å½•éŸ³ä¸­...ï¼ˆç‚¹å‡»åœæ­¢ä»¥ä¿å­˜ï¼‰");

      } catch (err) {
        log("âŒ å½•éŸ³å¤±è´¥: " + (err.message || err));
      }
    };

    function drawFFT() {
      if (!analyser) return;
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      analyser.getByteFrequencyData(dataArray);

      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const barWidth = (width / bufferLength) * 2.5;

      for (let i = 0; i < bufferLength; i++) {
        const barHeight = (dataArray[i] / 255) * height;
        ctx.fillStyle = 'cyan';
        ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
      }

      requestAnimationFrame(drawFFT);
    }

    // ================= åˆå§‹åŒ– =================
    if (hasMediaDevices) {
      // åˆå§‹æšä¸¾è®¾å¤‡ï¼ˆä¸ä¼šè¯·æ±‚æƒé™ï¼‰
      enumerateDevices();
      // ç›‘å¬è®¾å¤‡å˜åŒ–ï¼ˆå¦‚æ’æ‹”è€³æœºï¼‰
      navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);
    } else {
      log("âš ï¸ å½“å‰ç¯å¢ƒä¸æ”¯æŒåª’ä½“è®¾å¤‡ API");
    }

    log("è¯·ç‚¹å‡»ã€Œå¼€å§‹éŸ³é¢‘ã€å¹¶æˆæƒéº¦å…‹é£ï¼ˆéœ€ HTTPSï¼‰"); 
  </script>
</body>
</html>
