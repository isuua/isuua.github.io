<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¤ æ™ºèƒ½é™å™ªå½•éŸ³æœºï¼ˆè°±å‡æ³•ï¼‰</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --secondary: #64748b;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --background: #1a1a1a;
            --card: #242424;
            --border: #333;
            --text: #eee;
            --text-light: #999;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --radius: 8px;
            --transition: all 0.2s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        body {
            background-color: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 2rem 1rem;
            line-height: 1.5;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        .card {
            background: var(--card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            border: 1px solid var(--border);
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--primary);
        }

        .subtitle {
            text-align: center;
            color: var(--text-light);
            margin-bottom: 2rem;
        }

        .device-selectors {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 15px 0;
        }

        select, input[type="number"], button {
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            background: #444;
            color: white;
            cursor: pointer;
            font-size: 14px;
            min-width: 180px;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }

        input[type="number"] {
            width: auto;
            min-width: 60px;
            text-align: center;
            background: #333;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
        }

        .btn {
            border: none;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-width: 140px;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-hover);
        }

        .btn-success {
            background-color: var(--success);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger);
            color: white;
        }

        .btn-warning {
            background-color: var(--warning);
            color: white;
        }

        .btn:disabled {
            background: #333;
            color: #777;
            cursor: not-allowed;
        }

        .btn.active {
            background: #1e88e5;
        }

        .waveform-container {
            width: 100%;
            height: 280px;
            background-color: #000;
            border-radius: var(--radius);
            overflow: hidden;
            margin: 1.5rem 0;
            position: relative;
        }

        #waveform {
            width: 100%;
            height: 100%;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background-color: var(--card);
            border-radius: var(--radius);
            margin-bottom: 1rem;
            border: 1px solid var(--border);
        }

        .status {
            font-weight: 500;
        }

        .status-active {
            color: var(--success);
        }

        .status-inactive {
            color: var(--text-light);
        }

        .status-recording {
            color: var(--danger);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .timer {
            font-family: monospace;
            font-size: 1.1rem;
        }

        .settings {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 999px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .badge-active {
            background-color: rgba(16, 185, 129, 0.2);
            color: var(--success);
        }

        .badge-inactive {
            background-color: rgba(100, 116, 139, 0.2);
            color: var(--text-light);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
        }

        input[type="range"] {
            width: 120px;
        }

        #log {
            color: #ffcc00;
            font-size: 12px;
            margin-top: 10px;
            min-height: 20px;
            text-align: center;
        }

        /* æ–°å¢åº•å™ªé‡‡æ ·æ—¶é•¿è®¾ç½® */
        .sample-duration-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 0.5rem;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ æ™ºèƒ½é™å™ªå½•éŸ³æœºï¼ˆè°±å‡æ³•ï¼‰</h1>
        <p class="subtitle">å®æ—¶è°±å‡æ³•é™å™ª | è®¾å¤‡é€‰æ‹© | æ³¢å½¢å¯è§†åŒ– | æµæ¨¡å¼å½•éŸ³</p>

        <!-- è®¾å¤‡é€‰æ‹©åŒº -->
        <div class="card">
            <div class="device-selectors">
                <select id="inputSelect" disabled>
                    <option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>
                </select>
                <select id="outputSelect" disabled>
                    <option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>
                </select>
            </div>

            <!-- è®¾ç½®åŒº -->
            <div class="settings">
                <div class="slider-container">
                    <label>é™å™ªå¼ºåº¦:</label>
                    <input type="range" id="noise-reduction-strength" min="0" max="100" value="50" />
                    <span id="strength-value">50%</span>
                </div>
                <div class="sample-duration-container">
                    <label>åº•å™ªé‡‡æ ·æ—¶é•¿:</label>
                    <input type="range" id="noise-sample-duration" min="0.1" max="5" step="0.1" value="1" />
                    <span id="sample-duration-value">1s</span>
                </div>
                <div class="slider-container">
                    <label>äººå£°å¢ç›Š:</label>
                    <input type="range" id="gainSlider" min="0" max="300" value="150" />
                    <span id="gainValue">1.5x</span>
                </div>
                <div class="slider-container">
                    <label>æœ€å¤§æ—¶é•¿(ç§’):</label>
                    <input type="number" id="maxDurationInput" min="0" max="7200" value="0" />
                </div>
            </div>

            <!-- çŠ¶æ€ä¿¡æ¯ -->
            <div class="status-bar">
                <div class="status-container">
                    <span class="status" id="recorder-status">çŠ¶æ€: <span class="status-inactive">æœªå¯åŠ¨</span></span>
                    <span class="badge" id="noise-badge" style="margin-left: 1rem;">
                        <span class="badge-inactive">é™å™ªå·²å…³é—­</span>
                    </span>
                </div>
                <div class="timer" id="recording-timer">00:00:00</div>
            </div>
            
            <div id="log">å°±ç»ª</div>

            <!-- æ§åˆ¶æŒ‰é’® -->
            <div class="controls">
                <button id="startBtn" class="btn btn-primary">å¼€å§‹éŸ³é¢‘</button>
                <button id="stopBtn" class="btn btn-danger" disabled>å…³é—­éŸ³é¢‘</button>
                <button id="filterBtn" class="btn btn-warning" disabled>å¯ç”¨é™å™ª</button>
                <button id="recordBtn" class="btn btn-success" disabled>å¼€å§‹å½•éŸ³</button>
            </div>
        </div>

        <!-- æ³¢å½¢å¯è§†åŒ–åŒºåŸŸ -->
        <div class="card">
            <h3 style="margin-bottom: 1rem; text-align: center;">å®æ—¶å£°éŸ³æ³¢å½¢</h3>
            <div class="waveform-container">
                <canvas id="waveform"></canvas>
            </div>
        </div>
    </div>

    <script>
        // ================= å…¨å±€çŠ¶æ€ =================
        const logEl = document.getElementById('log');
        let audioContext = null;
        let stream = null;
        let sourceNode = null;
        let analyser = null;
        let masterGainNode = null;
        let isFiltering = false;
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let currentInputDeviceId = localStorage.getItem('audioInputDeviceId') || 'default';
        let currentOutputDeviceId = localStorage.getItem('audioOutputDeviceId') || 'default';
        let fftAnimationId = null;
        let recordingStartTime = null;
        let memoryGuardTimer = null;
        let recordingTimerInterval = null;
        let audioOutputElement = null;
        
        // è°±å‡æ³•é™å™ªç›¸å…³ï¼ˆå®Œå…¨å¤ç”¨å‚è€ƒä»£ç ï¼‰
        let noiseSampleBuffer = null; // åº•å™ªæ ·æœ¬ç¼“å­˜
        let noiseSpectrum = null;     // é¢„è®¡ç®—çš„å™ªå£°é¢‘è°±
        let denoiseProcessor = null;  // å®æ—¶é™å™ªå¤„ç†å™¨
        
        // é™å™ªå‚æ•°ï¼ˆå’Œå‚è€ƒä»£ç ä¸€è‡´ï¼‰
        const FFT_SIZE = 1024;
        const HOP_SIZE = FFT_SIZE / 2;
        const MAX_ESTIMATED_MEMORY_BYTES = 80 * 1024 * 1024;

        // DOM å…ƒç´ 
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const filterBtn = document.getElementById('filterBtn');
        const recordBtn = document.getElementById('recordBtn');
        const gainSlider = document.getElementById('gainSlider');
        const gainValue = document.getElementById('gainValue');
        const noiseReductionStrength = document.getElementById('noise-reduction-strength');
        const strengthValue = document.getElementById('strength-value');
        const noiseSampleDuration = document.getElementById('noise-sample-duration');
        const sampleDurationValue = document.getElementById('sample-duration-value');
        const maxDurationInput = document.getElementById('maxDurationInput');
        const waveformCanvas = document.getElementById('waveform');
        const recorderStatus = document.getElementById('recorder-status');
        const noiseBadge = document.getElementById('noise-badge');
        const recordingTimer = document.getElementById('recording-timer');
        
        let canvasContext;
        let canvasWidth;
        let canvasHeight;

        // ================= å·¥å…·å‡½æ•°ï¼ˆå¤ç”¨å‚è€ƒä»£ç ï¼‰=================
        function log(msg) {
            console.log(msg);
            logEl.textContent = msg;
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${hours}:${minutes}:${secs}`;
        }

        function updateRecordingTimer() {
            if (!recordingStartTime) return;
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimer.textContent = formatTime(elapsed);
        }

        // å½»åº•æ¸…ç†æ‰€æœ‰å½•éŸ³å®šæ—¶å™¨
        function clearAllRecordingTimers() {
            if (memoryGuardTimer) {
                clearInterval(memoryGuardTimer);
                memoryGuardTimer = null;
            }
            if (recordingTimerInterval) {
                clearInterval(recordingTimerInterval);
                recordingTimerInterval = null;
            }
            recordingTimer.textContent = '00:00:00';
            recordingStartTime = null;
        }

        function estimateRecordedSize() {
            if (!recordedChunks.length) return 0;
            return recordedChunks.reduce((total, chunk) => total + chunk.size, 0);
        }

        function checkMemoryPressure() {
            if (!isRecording || !recordingStartTime) return;

            const maxDurationSeconds = parseInt(maxDurationInput.value) || 0;

            if (maxDurationSeconds > 0) {
                const elapsedSeconds = (Date.now() - recordingStartTime) / 1000;
                if (elapsedSeconds >= maxDurationSeconds) {
                    log(`[è‡ªåŠ¨åœæ­¢] è¾¾åˆ°æœ€å¤§æ—¶é•¿: ${maxDurationSeconds}s`);
                    stopRecording(true).then(() => {
                        alert(`å½•éŸ³å·²è‡ªåŠ¨åœæ­¢ï¼ˆè¾¾åˆ°æœ€å¤§æ—¶é•¿ ${maxDurationSeconds} ç§’ï¼‰`);
                    });
                    return;
                }
            }

            if (maxDurationSeconds === 0) {
                const estimated = estimateRecordedSize();
                if (estimated > MAX_ESTIMATED_MEMORY_BYTES * 0.9) {
                    log(`[è‡ªåŠ¨åœæ­¢] å†…å­˜é™åˆ¶å·²è¾¾: ${(estimated / 1024 / 1024).toFixed(1)}MB`);
                    stopRecording(true).then(() => {
                        alert(`å½•éŸ³å·²è‡ªåŠ¨åœæ­¢ï¼ˆå†…å­˜å ç”¨è¾¾åˆ°é˜ˆå€¼ï¼‰`);
                    });
                }
            }
        }

        function generateFilename() {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            return `recording_${timestamp}.webm`;
        }

        // ================= è°±å‡æ³•æ ¸å¿ƒå‡½æ•°ï¼ˆå®Œå…¨å¤ç”¨å‚è€ƒä»£ç ï¼‰=================
        // æ±‰å®çª—å‡½æ•°
        function hanningWindow(size) {
            const window = new Float32Array(size);
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
            }
            return window;
        }

        // FFTç±»ï¼ˆå®Œå…¨å¤ç”¨ï¼‰
        class FFT {
            constructor(size, sampleRate) {
                this.size = size;
                this.sampleRate = sampleRate;
                this.real = new Float32Array(size);
                this.imag = new Float32Array(size);
                this.spectrum = new Float32Array(size);
                
                // é¢„è®¡ç®—æ—‹è½¬å› å­
                this.twiddle = new Array(size / 2);
                for (let i = 0; i < size / 2; i++) {
                    const angle = -2 * Math.PI * i / size;
                    this.twiddle[i] = {
                        re: Math.cos(angle),
                        im: Math.sin(angle)
                    };
                }
            }
            
            forward(input) {
                const n = this.size;
                const real = this.real;
                const imag = this.imag;
                
                // å¤åˆ¶è¾“å…¥æ•°æ®
                for (let i = 0; i < n; i++) {
                    real[i] = input[i] || 0;
                    imag[i] = 0;
                }
                
                // ä½åè½¬
                let j = 0;
                for (let i = 1; i < n; i++) {
                    let bit = n >> 1;
                    for (; j >= bit; bit >>= 1) {
                        j -= bit;
                    }
                    j += bit;
                    if (i < j) {
                        [real[i], real[j]] = [real[j], real[i]];
                        [imag[i], imag[j]] = [imag[j], imag[i]];
                    }
                }
                
                // Cooley-Tukey FFT ç®—æ³•
                for (let len = 2; len <= n; len <<= 1) {
                    const halfLen = len >> 1;
                    const step = n / len;
                    
                    for (let i = 0; i < n; i += len) {
                        for (let j = 0; j < halfLen; j++) {
                            const k = (j * step) % (n / 2);
                            const tRe = real[i + j + halfLen] * this.twiddle[k].re + imag[i + j + halfLen] * this.twiddle[k].im;
                            const tIm = imag[i + j + halfLen] * this.twiddle[k].re - real[i + j + halfLen] * this.twiddle[k].im;
                            
                            real[i + j + halfLen] = real[i + j] - tRe;
                            imag[i + j + halfLen] = imag[i + j] - tIm;
                            real[i + j] += tRe;
                            imag[i + j] += tIm;
                        }
                    }
                }
            }
            
            inverse() {
                const n = this.size;
                const real = this.real;
                const imag = this.imag;
                
                // å…±è½­
                for (let i = 0; i < n; i++) {
                    imag[i] = -imag[i];
                }
                
                // æ­£å‘ FFT
                this.forward(real);
                
                // ç¼©æ”¾å¹¶æ¢å¤å…±è½­
                for (let i = 0; i < n; i++) {
                    this.spectrum[i] = real[i] / n;
                    imag[i] = -imag[i] / n;
                }
            }
        }

        // é‡‡é›†åº•å™ªæ ·æœ¬ï¼ˆé€‚é…å®æ—¶åœºæ™¯ï¼‰
        async function collectNoiseSample() {
            if (!audioContext || !sourceNode) return;
            
            log("æ­£åœ¨é‡‡é›†åº•å™ªæ ·æœ¬...");
            
            // åˆ›å»ºä¸´æ—¶å¤„ç†å™¨é‡‡é›†æ ·æœ¬
            const sampleDuration = parseFloat(noiseSampleDuration.value);
            const sampleLength = Math.floor(sampleDuration * audioContext.sampleRate);
            const sampleBuffer = audioContext.createBuffer(1, sampleLength, audioContext.sampleRate);
            const sampleData = sampleBuffer.getChannelData(0);
            
            // åˆ›å»ºä¸´æ—¶åˆ†æå™¨
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = FFT_SIZE;
            sourceNode.connect(analyser);
            
            // é‡‡é›†æ ·æœ¬æ•°æ®
            const noiseData = new Float32Array(FFT_SIZE);
            const noiseFFT = new Array(FFT_SIZE / 2).fill(0);
            
            // ç­‰å¾…æ ·æœ¬é‡‡é›†
            await new Promise(resolve => setTimeout(resolve, sampleDuration * 1000));
            
            // åˆ†æå™ªå£°æ ·æœ¬ï¼Œè®¡ç®—å¹³å‡åŠŸç‡è°±
            for (let i = 0; i < sampleLength - FFT_SIZE; i += HOP_SIZE) {
                analyser.getFloatFrequencyData(noiseData);
                for (let j = 0; j < FFT_SIZE / 2; j++) {
                    noiseFFT[j] += Math.pow(10, noiseData[j] / 20);
                }
            }
            
            // å½’ä¸€åŒ–å™ªå£°é¢‘è°±
            for (let j = 0; j < FFT_SIZE / 2; j++) {
                noiseFFT[j] /= (sampleLength / HOP_SIZE);
            }
            
            noiseSampleBuffer = sampleBuffer;
            noiseSpectrum = noiseFFT;
            
            analyser.disconnect();
            log(`âœ… åº•å™ªæ ·æœ¬é‡‡é›†å®Œæˆï¼ˆ${sampleDuration}ç§’ï¼‰`);
        }

        // åˆ›å»ºå®æ—¶è°±å‡æ³•é™å™ªå¤„ç†å™¨
        function createSpectralSubtractionProcessor() {
            if (!audioContext || !noiseSpectrum) return null;
            
            // åˆ›å»ºScriptProcessorï¼ˆå®æ—¶å¤„ç†éŸ³é¢‘æµï¼‰
            const processor = audioContext.createScriptProcessor(1024, 1, 1);
            const fft = new FFT(FFT_SIZE, audioContext.sampleRate);
            const window = hanningWindow(FFT_SIZE);
            const overlapBuffer = new Float32Array(FFT_SIZE); // é‡å ç¼“å­˜
            
            processor.onaudioprocess = function(e) {
                const inputData = e.inputBuffer.getChannelData(0);
                const outputData = e.outputBuffer.getChannelData(0);
                const reductionStrength = parseFloat(noiseReductionStrength.value) / 100;
                const gain = parseFloat(gainSlider.value) / 100;
                
                // åˆå§‹åŒ–è¾“å‡º
                outputData.fill(0);
                
                // åˆ†å—å¤„ç†ï¼ˆé‡å ç›¸åŠ ï¼‰
                for (let i = 0; i < inputData.length - FFT_SIZE; i += HOP_SIZE) {
                    // æå–éŸ³é¢‘å—å¹¶åŠ çª—
                    const block = inputData.slice(i, i + FFT_SIZE).map((x, idx) => x * window[idx]);
                    
                    // æ‰§è¡Œ FFT å˜æ¢
                    fft.forward(block);
                    
                    // è°±å‡æ³•æ ¸å¿ƒï¼šå‡å»å™ªå£°åŠŸç‡
                    for (let j = 0; j < FFT_SIZE / 2; j++) {
                        const signalPower = fft.real[j] * fft.real[j] + fft.imag[j] * fft.imag[j];
                        const noisePower = noiseSpectrum[j] * reductionStrength * 2;
                        
                        // é¿å…å‡å»è¿‡å¤šå¯¼è‡´ä¿¡å·å¤±çœŸ
                        const cleanPower = Math.max(signalPower - noisePower, signalPower * 0.1);
                        
                        // æ¢å¤ç›¸ä½ä¿¡æ¯ï¼Œé‡å»ºé¢‘è°±
                        const magnitude = Math.sqrt(cleanPower);
                        const phase = Math.atan2(fft.imag[j], fft.real[j]);
                        
                        fft.real[j] = magnitude * Math.cos(phase);
                        fft.imag[j] = magnitude * Math.sin(phase);
                        
                        // å…±è½­å¯¹ç§°å¤„ç†
                        if (j > 0 && j < FFT_SIZE / 2) {
                            fft.real[FFT_SIZE - j] = fft.real[j];
                            fft.imag[FFT_SIZE - j] = -fft.imag[j];
                        }
                    }
                    
                    // é€† FFT è½¬æ¢å›æ—¶åŸŸ
                    fft.inverse();
                    
                    // é‡å ç›¸åŠ 
                    for (let j = 0; j < FFT_SIZE; j++) {
                        if (i + j < outputData.length) {
                            outputData[i + j] += (fft.spectrum[j] * window[j] / HOP_SIZE + overlapBuffer[j]) * gain;
                        }
                    }
                    
                    // æ›´æ–°é‡å ç¼“å­˜
                    overlapBuffer.set(outputData.slice(i + HOP_SIZE, i + FFT_SIZE));
                }
                
                // å¤„ç†å‰©ä½™æ•°æ®
                for (let i = Math.min(inputData.length - FFT_SIZE, inputData.length); i < inputData.length; i++) {
                    outputData[i] = inputData[i] * 0.5 * gain;
                }
            };
            
            return processor;
        }

        // ================= è®¾å¤‡å¤„ç† =================
        async function enumerateDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(d => d.kind === 'audioinput');
                const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

                // æ¸…ç©ºå¹¶é‡æ–°å¡«å……éº¦å…‹é£åˆ—è¡¨
                inputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>';
                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `éº¦å…‹é£ ${inputSelect.children.length}`;
                    if (device.deviceId === currentInputDeviceId) option.selected = true;
                    inputSelect.appendChild(option);
                });

                // æ£€æŸ¥æ‰¬å£°å™¨é€‰æ‹©æ”¯æŒ
                if (typeof HTMLAudioElement.prototype.setSinkId === 'function') {
                    outputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>';
                    audioOutputs.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `æ‰¬å£°å™¨ ${outputSelect.children.length}`;
                        if (device.deviceId === currentOutputDeviceId) option.selected = true;
                        outputSelect.appendChild(option);
                    });
                    outputSelect.disabled = false;
                } else {
                    outputSelect.innerHTML = '<option>å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‰¬å£°å™¨é€‰æ‹©</option>';
                    outputSelect.disabled = true;
                }

                inputSelect.disabled = false;
                log("âœ… è®¾å¤‡åˆ—è¡¨å·²æ›´æ–°");
            } catch (err) {
                log("âŒ è®¾å¤‡æšä¸¾å¤±è´¥: " + err.message);
            }
        }

        // è®¾ç½®è¾“å‡ºè®¾å¤‡
        async function setAudioOutputDevice(deviceId) {
            if (!audioOutputElement) {
                audioOutputElement = new Audio();
            }
            
            if (deviceId && deviceId !== 'default' && typeof audioOutputElement.setSinkId === 'function') {
                try {
                    await audioOutputElement.setSinkId(deviceId);
                    log(`âœ… è¾“å‡ºè®¾å¤‡å·²åˆ‡æ¢åˆ°: ${deviceId.substring(0, 8)}...`);
                } catch (err) {
                    log(`âš ï¸ åˆ‡æ¢è¾“å‡ºè®¾å¤‡å¤±è´¥: ${err.message}`);
                }
            }
        }

        // ================= ç”»å¸ƒåˆå§‹åŒ– =================
        function initCanvas() {
            canvasContext = waveformCanvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const container = waveformCanvas.parentElement;
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            waveformCanvas.width = canvasWidth * window.devicePixelRatio;
            waveformCanvas.height = canvasHeight * window.devicePixelRatio;
            canvasContext.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        // ================= éŸ³é¢‘å›¾æ„å»ºï¼ˆé€‚é…è°±å‡æ³•ï¼‰=================
        async function buildAudioGraph(enableFilter) {
            // åœæ­¢æ—§çš„FFTç»˜åˆ¶
            if (fftAnimationId) {
                cancelAnimationFrame(fftAnimationId);
                fftAnimationId = null;
            }

            // é‡ç½®åˆ†æå™¨
            if (analyser) {
                try { analyser.disconnect(); } catch (e) {}
                analyser = null;
            }
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024;
            analyser.smoothingTimeConstant = 0.5;

            // ä¸»å¢ç›ŠèŠ‚ç‚¹
            if (!masterGainNode) {
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.value = 1.0;
            }

            // æ–­å¼€æ—§è¿æ¥
            try { sourceNode.disconnect(); } catch (e) {}
            
            // æ–­å¼€æ—§çš„é™å™ªå¤„ç†å™¨
            if (denoiseProcessor) {
                try { denoiseProcessor.disconnect(); } catch (e) {}
                denoiseProcessor = null;
            }

            if (enableFilter) {
                // å¯ç”¨è°±å‡æ³•é™å™ª
                if (!noiseSpectrum) {
                    await collectNoiseSample(); // å…ˆé‡‡é›†åº•å™ª
                }
                
                denoiseProcessor = createSpectralSubtractionProcessor();
                if (denoiseProcessor) {
                    sourceNode.connect(denoiseProcessor);
                    denoiseProcessor.connect(analyser);
                    analyser.connect(masterGainNode);
                    noiseBadge.innerHTML = '<span class="badge-active">è°±å‡æ³•é™å™ªå·²å¼€å¯</span>';
                    log("âœ… è°±å‡æ³•é™å™ªå·²å¯ç”¨ï¼ˆåŸºäºå‚è€ƒä»£ç ï¼‰");
                } else {
                    // é™çº§å¤„ç†
                    sourceNode.connect(analyser);
                    analyser.connect(masterGainNode);
                    log("âš ï¸ é™å™ªå¤„ç†å™¨åˆ›å»ºå¤±è´¥ï¼Œä½¿ç”¨åŸå§‹éŸ³é¢‘");
                }
            } else {
                // ç¦ç”¨é™å™ª
                sourceNode.connect(analyser);
                analyser.connect(masterGainNode);
                noiseBadge.innerHTML = '<span class="badge-inactive">é™å™ªå·²å…³é—­</span>';
                log("âœ… é™å™ªå·²å…³é—­");
            }

            // è¿æ¥åˆ°è¾“å‡ºè®¾å¤‡
            masterGainNode.connect(audioContext.destination);
            
            // å¦‚æœæœ‰æŒ‡å®šçš„è¾“å‡ºè®¾å¤‡ï¼Œé€šè¿‡AudioElementæ’­æ”¾
            if (audioOutputElement && currentOutputDeviceId && currentOutputDeviceId !== 'default') {
                const dest = audioContext.createMediaStreamDestination();
                masterGainNode.connect(dest);
                audioOutputElement.srcObject = dest.stream;
                audioOutputElement.play().catch(e => log(`âš ï¸ æ’­æ”¾é”™è¯¯: ${e.message}`));
            }

            // å¯åŠ¨FFTç»˜åˆ¶
            drawWaveform();
        }

        // ================= æ³¢å½¢ç»˜åˆ¶ =================
        function drawWaveform() {
            if (!analyser) return;
            
            fftAnimationId = requestAnimationFrame(() => {
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(dataArray);
                
                // æ¸…ç©ºç”»å¸ƒ
                canvasContext.clearRect(0, 0, canvasWidth, canvasHeight);
                
                // ç»˜åˆ¶æ³¢å½¢
                canvasContext.lineWidth = 2;
                canvasContext.strokeStyle = '#2563eb';
                canvasContext.beginPath();
                
                const sliceWidth = canvasWidth / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvasHeight / 2;
                    
                    if (i === 0) {
                        canvasContext.moveTo(x, y);
                    } else {
                        canvasContext.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                canvasContext.lineTo(canvasWidth, canvasHeight / 2);
                canvasContext.stroke();
                
                drawWaveform();
            });
        }

        // ================= å½•éŸ³æ§åˆ¶ =================
        async function stopRecording(save = true) {
            // åŒé‡æ ¡éªŒï¼Œé˜²æ­¢é‡å¤è°ƒç”¨
            if (!isRecording || !mediaRecorder) {
                log("âš ï¸ æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„å½•éŸ³");
                return;
            }

            try {
                // ç«‹å³æ›´æ–°çŠ¶æ€æ ‡è®°
                isRecording = false;
                
                // ç¦ç”¨å½•éŸ³æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
                recordBtn.disabled = true;
                recordBtn.textContent = "åœæ­¢ä¸­...";

                // æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
                clearAllRecordingTimers();

                // åœæ­¢MediaRecorder
                if (mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }

                // ä¿å­˜å½•éŸ³æ–‡ä»¶
                if (save && recordedChunks.length > 0) {
                    const filename = generateFilename();
                    const blob = new Blob(recordedChunks, { 
                        type: 'audio/webm;codecs=opus' 
                    });
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    log(`âœ… å½•éŸ³å·²ä¿å­˜: ${filename}`);
                }

                // é‡ç½®å½•éŸ³ç›¸å…³å˜é‡
                recordedChunks = [];
                mediaRecorder = null;

                // æ›´æ–°UIçŠ¶æ€
                recordBtn.textContent = "å¼€å§‹å½•éŸ³";
                recordBtn.classList.remove('active');
                recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-active">å·²å¯åŠ¨</span>';
                recordBtn.disabled = false;

                log("âœ… å½•éŸ³å·²åœæ­¢");

            } catch (err) {
                log(`âŒ åœæ­¢å½•éŸ³å¤±è´¥: ${err.message}`);
                console.error("åœæ­¢å½•éŸ³é”™è¯¯:", err);
                
                // å…œåº•é‡ç½®çŠ¶æ€
                isRecording = false;
                clearAllRecordingTimers();
                recordedChunks = [];
                mediaRecorder = null;
                
                recordBtn.textContent = "å¼€å§‹å½•éŸ³";
                recordBtn.classList.remove('active');
                recordBtn.disabled = false;
            }
        }

        async function startRecording() {
            // é˜²æ­¢é‡å¤å¯åŠ¨
            if (isRecording || !audioContext || !analyser) {
                log("âš ï¸ æ— æ³•å¼€å§‹å½•éŸ³ï¼ˆéŸ³é¢‘æœªå¯åŠ¨æˆ–å·²æœ‰å½•éŸ³ï¼‰");
                return;
            }

            try {
                // åˆ›å»ºå½•éŸ³ç›®æ ‡
                const dest = audioContext.createMediaStreamDestination();
                if (isFiltering && denoiseProcessor) {
                    denoiseProcessor.connect(dest);
                } else {
                    analyser.connect(dest);
                }

                // åˆå§‹åŒ–MediaRecorder
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                    ? 'audio/webm;codecs=opus' 
                    : 'audio/webm';
                
                mediaRecorder = new MediaRecorder(dest.stream, { 
                    mimeType,
                    audioBitsPerSecond: 128000 
                });

                // å¤„ç†å½•éŸ³æ•°æ®
                recordedChunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0 && isRecording) {
                        recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.onerror = (e) => {
                    log(`âš ï¸ å½•éŸ³é”™è¯¯: ${e.error}`);
                    stopRecording(false).catch(err => console.error(err));
                };

                // å½•éŸ³ç»“æŸå›è°ƒ
                mediaRecorder.onstop = () => {
                    if (isRecording) {
                        stopRecording(true).catch(err => console.error(err));
                    }
                };

                // å¼€å§‹å½•éŸ³
                mediaRecorder.start(100);
                isRecording = true;
                recordingStartTime = Date.now();
                
                // å¯åŠ¨å®šæ—¶å™¨
                memoryGuardTimer = setInterval(checkMemoryPressure, 500);
                recordingTimerInterval = setInterval(updateRecordingTimer, 1000);

                // æ›´æ–°UI
                recordBtn.textContent = "åœæ­¢å½•éŸ³";
                recordBtn.classList.add('active');
                recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-recording">æ­£åœ¨å½•éŸ³</span>';
                log("ğŸ™ï¸ å½•éŸ³å·²å¼€å§‹ï¼ˆè°±å‡æ³•é™å™ªæ¨¡å¼ï¼‰");

            } catch (err) {
                log(`âŒ å½•éŸ³å¯åŠ¨å¤±è´¥: ${err.message}`);
                console.error("å¯åŠ¨å½•éŸ³é”™è¯¯:", err);
                
                // å…œåº•æ¸…ç†
                isRecording = false;
                clearAllRecordingTimers();
                recordedChunks = [];
                mediaRecorder = null;
            }
        }

        // ================= éŸ³é¢‘æ§åˆ¶ =================
        async function startAudio() {
            try {
                log("æ­£åœ¨å¯åŠ¨éŸ³é¢‘...");

                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 44100
                    });
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // åˆ›å»ºéŸ³é¢‘è¾“å‡ºå…ƒç´ 
                audioOutputElement = new Audio();
                
                // è®¾ç½®è¾“å‡ºè®¾å¤‡
                if (currentOutputDeviceId && currentOutputDeviceId !== 'default') {
                    await setAudioOutputDevice(currentOutputDeviceId);
                }

                // è¯·æ±‚éº¦å…‹é£æµ
                const constraints = {
                    audio: {
                        deviceId: currentInputDeviceId === 'default' ? undefined : { exact: currentInputDeviceId },
                        sampleRate: 44100,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                sourceNode = audioContext.createMediaStreamSource(stream);

                // åˆå§‹åŒ–ä¸»å¢ç›ŠèŠ‚ç‚¹
                if (!masterGainNode) {
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = 1.0;
                    masterGainNode.connect(audioContext.destination);
                }

                // æ„å»ºéŸ³é¢‘å›¾ï¼ˆåˆå§‹ç¦ç”¨é™å™ªï¼‰
                await buildAudioGraph(false);

                // æ›´æ–°UIçŠ¶æ€
                startBtn.disabled = true;
                startBtn.textContent = "âœ… éŸ³é¢‘è¿è¡Œä¸­";
                stopBtn.disabled = false;
                filterBtn.disabled = false;
                recordBtn.disabled = false;
                inputSelect.disabled = true;
                outputSelect.disabled = true;
                recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-active">å·²å¯åŠ¨</span>';
                log("âœ… éŸ³é¢‘å·²å¯åŠ¨ï¼");

            } catch (err) {
                log(`âŒ éº¦å…‹é£é”™è¯¯: ${err.message}`);
                alert("æ— æ³•è®¿é—®éº¦å…‹é£: " + err.message);
                
                // æ¸…ç†èµ„æº
                if (audioContext) await audioContext.close();
                audioContext = null;
                stream = null;
                sourceNode = null;
                
                // é‡ç½®UI
                startBtn.disabled = false;
                startBtn.textContent = "å¼€å§‹éŸ³é¢‘";
            }
        }

        async function stopAllAudio() {
            log("æ­£åœ¨å…³é—­éŸ³é¢‘...");
            
            // å…ˆåœæ­¢å½•éŸ³
            if (isRecording) {
                await stopRecording(false);
            }

            // åœæ­¢FFTç»˜åˆ¶
            if (fftAnimationId) {
                cancelAnimationFrame(fftAnimationId);
                fftAnimationId = null;
            }

            // æ¸…ç†å®šæ—¶å™¨
            clearAllRecordingTimers();

            // åœæ­¢åª’ä½“æµ
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }

            // å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (audioContext) {
                try { await audioContext.close(); } catch (e) {}
                audioContext = null;
            }

            // æ¸…ç†éŸ³é¢‘è¾“å‡ºå…ƒç´ 
            if (audioOutputElement) {
                audioOutputElement.pause();
                audioOutputElement.srcObject = null;
                audioOutputElement = null;
            }

            // é‡ç½®èŠ‚ç‚¹å’Œé™å™ªç›¸å…³
            sourceNode = null;
            analyser = null;
            masterGainNode = null;
            noiseSampleBuffer = null;
            noiseSpectrum = null;
            if (denoiseProcessor) {
                try { denoiseProcessor.disconnect(); } catch (e) {}
                denoiseProcessor = null;
            }
            isFiltering = false;
            isRecording = false;

            // é‡ç½®UI
            startBtn.disabled = false;
            startBtn.textContent = "å¼€å§‹éŸ³é¢‘";
            stopBtn.disabled = true;
            filterBtn.disabled = true;
            filterBtn.classList.remove('active');
            filterBtn.textContent = "å¯ç”¨é™å™ª";
            recordBtn.disabled = true;
            recordBtn.classList.remove('active');
            recordBtn.textContent = "å¼€å§‹å½•éŸ³";
            inputSelect.disabled = false;
            outputSelect.disabled = false;
            recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-inactive">æœªå¯åŠ¨</span>';
            noiseBadge.innerHTML = '<span class="badge-inactive">é™å™ªå·²å…³é—­</span>';
            
            log("âœ… éŸ³é¢‘å·²å…³é—­");
        }

        // ================= äº‹ä»¶ç»‘å®š =================
        document.addEventListener('DOMContentLoaded', async () => {
            // åˆå§‹åŒ–ç”»å¸ƒ
            initCanvas();
            
            // æ›´æ–°æ»‘å—æ˜¾ç¤º
            strengthValue.textContent = `${noiseReductionStrength.value}%`;
            sampleDurationValue.textContent = `${noiseSampleDuration.value}s`;
            gainValue.textContent = `${(gainSlider.value / 100).toFixed(1)}x`;

            // é™å™ªå¼ºåº¦æ»‘å—
            noiseReductionStrength.addEventListener('input', () => {
                strengthValue.textContent = `${noiseReductionStrength.value}%`;
            });
            
            // åº•å™ªé‡‡æ ·æ—¶é•¿æ»‘å—
            noiseSampleDuration.addEventListener('input', () => {
                sampleDurationValue.textContent = `${noiseSampleDuration.value}s`;
            });

            // å¢ç›Šæ»‘å—
            gainSlider.addEventListener('input', () => {
                const g = gainSlider.value / 100;
                gainValue.textContent = g.toFixed(1) + 'x';
            });

            // è®¾å¤‡é€‰æ‹©å˜æ›´
            inputSelect.onchange = () => {
                currentInputDeviceId = inputSelect.value || 'default';
                localStorage.setItem('audioInputDeviceId', currentInputDeviceId);
            };

            outputSelect.onchange = () => {
                if (outputSelect.disabled) return;
                currentOutputDeviceId = outputSelect.value || 'default';
                localStorage.setItem('audioOutputDeviceId', currentOutputDeviceId);
            };

            // æŒ‰é’®äº‹ä»¶
            startBtn.addEventListener('click', startAudio);
            stopBtn.addEventListener('click', stopAllAudio);
            
            filterBtn.addEventListener('click', async () => {
                isFiltering = !isFiltering;
                filterBtn.classList.toggle('active', isFiltering);
                filterBtn.textContent = isFiltering ? "å…³é—­é™å™ª" : "å¯ç”¨é™å™ª";
                if (audioContext) {
                    await buildAudioGraph(isFiltering);
                }
            });
            
            // å½•éŸ³æŒ‰é’®äº‹ä»¶
            recordBtn.addEventListener('click', async () => {
                if (isRecording) {
                    await stopRecording(true);
                } else {
                    await startRecording();
                }
            });

            // åˆå§‹åŒ–è®¾å¤‡åˆ—è¡¨
            try {
                // è¯·æ±‚ä¸´æ—¶æƒé™ä»¥æšä¸¾è®¾å¤‡
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                tempStream.getTracks().forEach(track => track.stop());
                await enumerateDevices();
            } catch (err) {
                log("âš ï¸ éœ€è¦éº¦å…‹é£æƒé™æ‰èƒ½æšä¸¾è®¾å¤‡");
                enumerateDevices();
            }

            // ç›‘å¬è®¾å¤‡å˜åŒ–
            navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);
        });
    </script>
</body>
</html>
