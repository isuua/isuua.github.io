<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½é™å™ªå½•éŸ³æœº</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --secondary: #64748b;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --background: #1a1a1a;
            --card: #242424;
            --border: #333;
            --text: #eee;
            --text-light: #999;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --radius: 8px;
            --transition: all 0.2s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        body {
            background-color: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 2rem 1rem;
            line-height: 1.5;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        .card {
            background: var(--card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            border: 1px solid var(--border);
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--primary);
        }

        .subtitle {
            text-align: center;
            color: var(--text-light);
            margin-bottom: 2rem;
        }

        .device-selectors {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 15px 0;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        select, input[type="number"], button {
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            background: #444;
            color: white;
            cursor: pointer;
            font-size: 14px;
            min-width: 180px;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }

        input[type="number"] {
            width: auto;
            min-width: 60px;
            text-align: center;
            background: #333;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
        }

        .btn {
            border: none;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-width: 140px;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-hover);
        }

        .btn-success {
            background-color: var(--success);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger);
            color: white;
        }

        .btn-warning {
            background-color: var(--warning);
            color: white;
        }

        .btn:disabled {
            background: #333;
            color: #777;
            cursor: not-allowed;
        }

        .btn.active {
            background: #1e88e5;
        }

        .waveform-container {
            width: 100%;
            height: 280px;
            background-color: #000;
            border-radius: var(--radius);
            overflow: hidden;
            margin: 1.5rem 0;
            position: relative;
        }

        #waveform {
            width: 100%;
            height: 100%;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background-color: var(--card);
            border-radius: var(--radius);
            margin-bottom: 1rem;
            border: 1px solid var(--border);
        }

        .status {
            font-weight: 500;
        }

        .status-active {
            color: var(--success);
        }

        .status-inactive {
            color: var(--text-light);
        }

        .status-recording {
            color: var(--danger);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .timer {
            font-family: monospace;
            font-size: 1.1rem;
        }

        .settings {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 999px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .badge-active {
            background-color: rgba(16, 185, 129, 0.2);
            color: var(--success);
        }

        .badge-inactive {
            background-color: rgba(100, 116, 139, 0.2);
            color: var(--text-light);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
        }

        input[type="range"] {
            width: 120px;
        }

        #log {
            color: #ffcc00;
            font-size: 12px;
            margin-top: 10px;
            min-height: 20px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 0.5rem;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ æ™ºèƒ½é™å™ªå½•éŸ³æœº</h1>
        <p class="subtitle">å®æ—¶é™å™ª | è®¾å¤‡é€‰æ‹© | æ³¢å½¢å¯è§†åŒ– | æµæ¨¡å¼å½•éŸ³</p>

        <!-- è®¾å¤‡é€‰æ‹©åŒº -->
        <div class="card">
            <div class="device-selectors">
                <select id="inputSelect" disabled>
                    <option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>
                </select>
                <select id="outputSelect" disabled>
                    <option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>
                </select>
            </div>

            <!-- è®¾ç½®åŒº -->
            <div class="settings">
                <div class="slider-container">
                    <label>é™å™ªå¼ºåº¦:</label>
                    <input type="range" id="noise-reduction-strength" min="0" max="100" value="50" />
                    <span id="strength-value">50%</span>
                </div>
                <div class="slider-container">
                    <label>äººå£°å¢ç›Š:</label>
                    <input type="range" id="gainSlider" min="0" max="300" value="150" />
                    <span id="gainValue">1.5x</span>
                </div>
                <div class="slider-container">
                    <label>æœ€å¤§æ—¶é•¿(ç§’):</label>
                    <input type="number" id="maxDurationInput" min="0" max="7200" value="0" />
                </div>
            </div>

            <!-- çŠ¶æ€ä¿¡æ¯ -->
            <div class="status-bar">
                <div class="status-container">
                    <span class="status" id="recorder-status">çŠ¶æ€: <span class="status-inactive">æœªå¯åŠ¨</span></span>
                    <span class="badge" id="noise-badge" style="margin-left: 1rem;">
                        <span class="badge-inactive">é™å™ªå·²å…³é—­</span>
                    </span>
                </div>
                <div class="timer" id="recording-timer">00:00:00</div>
            </div>
            
            <div id="log">å°±ç»ª</div>

            <!-- æ§åˆ¶æŒ‰é’® -->
            <div class="controls">
                <button id="startBtn" class="btn btn-primary">å¼€å§‹éŸ³é¢‘</button>
                <button id="stopBtn" class="btn btn-danger" disabled>å…³é—­éŸ³é¢‘</button>
                <button id="filterBtn" class="btn btn-warning" disabled>å¯ç”¨é™å™ª</button>
                <button id="recordBtn" class="btn btn-success" disabled>å¼€å§‹å½•éŸ³</button>
            </div>
        </div>

        <!-- æ³¢å½¢å¯è§†åŒ–åŒºåŸŸ -->
        <div class="card">
            <h3 style="margin-bottom: 1rem; text-align: center;">å®æ—¶å£°éŸ³æ³¢å½¢</h3>
            <div class="waveform-container">
                <canvas id="waveform"></canvas>
            </div>
        </div>
    </div>

    <script>
        // ================= å…¨å±€çŠ¶æ€ =================
        const logEl = document.getElementById('log');
        let audioContext = null;
        let stream = null;
        let sourceNode = null;
        let analyser = null;
        let masterGainNode = null;
        let compressorNode = null;
        let filterChain = [];
        let isFiltering = false;
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let currentInputDeviceId = localStorage.getItem('audioInputDeviceId') || 'default';
        let currentOutputDeviceId = localStorage.getItem('audioOutputDeviceId') || 'default';
        let fftAnimationId = null;
        let recordingStartTime = null;
        let memoryGuardTimer = null;
        let audioOutputElement = null;
        
        // è®¾å¤‡ç›¸å…³
        const inputSelect = document.getElementById('inputSelect');
        const outputSelect = document.getElementById('outputSelect');
        
        // é™å™ªé…ç½®
        const POWER_FREQ = 50;
        const notchFreqs = [
            POWER_FREQ, POWER_FREQ * 2, POWER_FREQ * 3,
            POWER_FREQ * 4, POWER_FREQ * 5, POWER_FREQ * 6,
            19.9, 60.1, 180.2
        ];
        const Q_BASE = 50;
        const Q_HARMONIC = 30;
        const Q_NARROW = 80;
        const HPF_FREQ = 55;
        const LPF_FREQ = 18000;
        const MAX_ESTIMATED_MEMORY_BYTES = 80 * 1024 * 1024;

        // DOM å…ƒç´ 
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const filterBtn = document.getElementById('filterBtn');
        const recordBtn = document.getElementById('recordBtn');
        const gainSlider = document.getElementById('gainSlider');
        const gainValue = document.getElementById('gainValue');
        const noiseReductionStrength = document.getElementById('noise-reduction-strength');
        const strengthValue = document.getElementById('strength-value');
        const maxDurationInput = document.getElementById('maxDurationInput');
        const waveformCanvas = document.getElementById('waveform');
        const recorderStatus = document.getElementById('recorder-status');
        const noiseBadge = document.getElementById('noise-badge');
        const recordingTimer = document.getElementById('recording-timer');
        
        let canvasContext;
        let canvasWidth;
        let canvasHeight;

        // ================= å·¥å…·å‡½æ•° =================
        function log(msg) {
            console.log(msg);
            logEl.textContent = msg;
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${hours}:${minutes}:${secs}`;
        }

        function updateRecordingTimer() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimer.textContent = formatTime(elapsed);
        }

        function stopRecordingTimer() {
            clearInterval(memoryGuardTimer);
            clearTimeout(timeoutTimer);
            recordingTimer.textContent = '00:00:00';
        }

        function estimateRecordedSize() {
            if (!recordedChunks.length) return 0;
            return recordedChunks.reduce((total, chunk) => total + chunk.size, 0);
        }

        function checkMemoryPressure() {
            if (!isRecording || !recordingStartTime) return;

            const maxDurationSeconds = parseInt(maxDurationInput.value) || 0;

            if (maxDurationSeconds > 0) {
                const elapsedSeconds = (Date.now() - recordingStartTime) / 1000;
                if (elapsedSeconds >= maxDurationSeconds) {
                    log(`[è‡ªåŠ¨åœæ­¢] è¾¾åˆ°æœ€å¤§æ—¶é•¿: ${maxDurationSeconds}s`);
                    stopRecording(true);
                    return;
                }
            }

            if (maxDurationSeconds === 0) {
                const estimated = estimateRecordedSize();
                if (estimated > MAX_ESTIMATED_MEMORY_BYTES * 0.9) {
                    log(`[è‡ªåŠ¨åœæ­¢] å†…å­˜é™åˆ¶å·²è¾¾: ${(estimated / 1024 / 1024).toFixed(1)}MB`);
                    stopRecording(true);
                }
            }
        }

        function generateFilename() {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            return `recording_${timestamp}.webm`;
        }

        // ================= è®¾å¤‡å¤„ç† =================
        async function enumerateDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(d => d.kind === 'audioinput');
                const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

                // æ¸…ç©ºå¹¶é‡æ–°å¡«å……éº¦å…‹é£åˆ—è¡¨
                inputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>';
                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `éº¦å…‹é£ ${inputSelect.children.length}`;
                    if (device.deviceId === currentInputDeviceId) option.selected = true;
                    inputSelect.appendChild(option);
                });

                // æ£€æŸ¥æ‰¬å£°å™¨é€‰æ‹©æ”¯æŒ
                if (typeof HTMLAudioElement.prototype.setSinkId === 'function') {
                    outputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>';
                    audioOutputs.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `æ‰¬å£°å™¨ ${outputSelect.children.length}`;
                        if (device.deviceId === currentOutputDeviceId) option.selected = true;
                        outputSelect.appendChild(option);
                    });
                    outputSelect.disabled = false;
                } else {
                    outputSelect.innerHTML = '<option>å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‰¬å£°å™¨é€‰æ‹©</option>';
                    outputSelect.disabled = true;
                }

                inputSelect.disabled = false;
                log("âœ… è®¾å¤‡åˆ—è¡¨å·²æ›´æ–°");
            } catch (err) {
                log("âŒ è®¾å¤‡æšä¸¾å¤±è´¥: " + err.message);
            }
        }

        // è®¾ç½®è¾“å‡ºè®¾å¤‡
        async function setAudioOutputDevice(deviceId) {
            if (!audioOutputElement) {
                audioOutputElement = new Audio();
            }
            
            if (deviceId && deviceId !== 'default' && typeof audioOutputElement.setSinkId === 'function') {
                try {
                    await audioOutputElement.setSinkId(deviceId);
                    log(`âœ… è¾“å‡ºè®¾å¤‡å·²åˆ‡æ¢åˆ°: ${deviceId.substring(0, 8)}...`);
                } catch (err) {
                    log(`âš ï¸ åˆ‡æ¢è¾“å‡ºè®¾å¤‡å¤±è´¥: ${err.message}`);
                }
            }
        }

        // ================= ç”»å¸ƒåˆå§‹åŒ– =================
        function initCanvas() {
            canvasContext = waveformCanvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const container = waveformCanvas.parentElement;
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            waveformCanvas.width = canvasWidth * window.devicePixelRatio;
            waveformCanvas.height = canvasHeight * window.devicePixelRatio;
            canvasContext.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        // ================= é™å™ªæ»¤æ³¢é“¾ =================
        function createHighEffectNoiseFilter() {
            // æ¸…ç©ºæ—§æ»¤æ³¢é“¾
            filterChain.forEach(node => {
                try { node.disconnect(); } catch (e) {}
            });
            filterChain = [];

            // 1. é«˜é€šæ»¤æ³¢å™¨
            const highpass = audioContext.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.value = HPF_FREQ;
            highpass.Q.value = 0.7;
            filterChain.push(highpass);

            // 2. é™·æ³¢æ»¤æ³¢å™¨ï¼ˆå·¥é¢‘é™å™ªï¼‰
            notchFreqs.forEach((freq, index) => {
                const notch = audioContext.createBiquadFilter();
                notch.type = 'notch';
                notch.frequency.value = freq;
                
                if (index === 0) {
                    notch.Q.value = Q_BASE * (noiseReductionStrength.value / 100);
                } else if (index < 6) {
                    notch.Q.value = Q_HARMONIC * (noiseReductionStrength.value / 100);
                } else {
                    notch.Q.value = Q_NARROW * (noiseReductionStrength.value / 100);
                }
                
                filterChain[filterChain.length-1].connect(notch);
                filterChain.push(notch);
            });

            // 3. ä½é€šæ»¤æ³¢å™¨
            const lowpass = audioContext.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = LPF_FREQ;
            lowpass.Q.value = 0.7;
            filterChain[filterChain.length-1].connect(lowpass);
            filterChain.push(lowpass);

            // 4. äººå£°å¢ç›Šè¡¥å¿
            const peaking = audioContext.createBiquadFilter();
            peaking.type = 'peaking';
            peaking.frequency.value = 1850;
            peaking.gain.value = (parseFloat(gainSlider.value) / 100) - 1;
            peaking.Q.value = 0.8;
            filterChain[filterChain.length-1].connect(peaking);
            filterChain.push(peaking);

            // 5. å¢ç›Šæ§åˆ¶
            const gain = audioContext.createGain();
            gain.gain.value = parseFloat(gainSlider.value) / 100;
            filterChain[filterChain.length-1].connect(gain);
            filterChain.push(gain);

            // 6. å‹ç¼©å™¨
            if (!compressorNode) {
                compressorNode = audioContext.createDynamicsCompressor();
                compressorNode.threshold.value = -18;
                compressorNode.knee.value = 10;
                compressorNode.ratio.value = 2;
                compressorNode.attack.value = 0.01;
                compressorNode.release.value = 0.3;
            }
            filterChain[filterChain.length-1].connect(compressorNode);
            filterChain.push(compressorNode);

            return {
                input: filterChain[0],
                output: filterChain[filterChain.length-1]
            };
        }

        // ================= éŸ³é¢‘å›¾æ„å»º =================
        function buildAudioGraph(enableFilter) {
            // åœæ­¢æ—§çš„FFTç»˜åˆ¶
            if (fftAnimationId) {
                cancelAnimationFrame(fftAnimationId);
                fftAnimationId = null;
            }

            // é‡ç½®åˆ†æå™¨
            if (analyser) {
                try { analyser.disconnect(); } catch (e) {}
                analyser = null;
            }
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024;
            analyser.smoothingTimeConstant = 0.5;

            // ä¸»å¢ç›ŠèŠ‚ç‚¹
            if (!masterGainNode) {
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.value = 1.0;
            }

            // æ–­å¼€æ—§è¿æ¥
            try { sourceNode.disconnect(); } catch (e) {}

            if (enableFilter) {
                // å¯ç”¨é™å™ª
                const filter = createHighEffectNoiseFilter();
                sourceNode.connect(filter.input);
                filter.output.connect(analyser);
                analyser.connect(masterGainNode);
                noiseBadge.innerHTML = '<span class="badge-active">é™å™ªå·²å¼€å¯</span>';
                log("âœ… é™å™ªå·²å¯ç”¨ï¼ˆå¼ºå·¥é¢‘é™å™ª+å°–å³°å‹åˆ¶ï¼‰");
            } else {
                // ç¦ç”¨é™å™ª
                sourceNode.connect(analyser);
                analyser.connect(masterGainNode);
                noiseBadge.innerHTML = '<span class="badge-inactive">é™å™ªå·²å…³é—­</span>';
                log("âœ… é™å™ªå·²å…³é—­");
            }

            // è¿æ¥åˆ°è¾“å‡ºè®¾å¤‡
            masterGainNode.connect(audioContext.destination);
            
            // å¦‚æœæœ‰æŒ‡å®šçš„è¾“å‡ºè®¾å¤‡ï¼Œé€šè¿‡AudioElementæ’­æ”¾
            if (audioOutputElement && currentOutputDeviceId && currentOutputDeviceId !== 'default') {
                const dest = audioContext.createMediaStreamDestination();
                masterGainNode.connect(dest);
                audioOutputElement.srcObject = dest.stream;
                audioOutputElement.play().catch(e => log(`âš ï¸ æ’­æ”¾é”™è¯¯: ${e.message}`));
            }

            // å¯åŠ¨FFTç»˜åˆ¶
            drawWaveform();
        }

        // ================= æ³¢å½¢ç»˜åˆ¶ =================
        function drawWaveform() {
            if (!analyser) return;
            
            fftAnimationId = requestAnimationFrame(() => {
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(dataArray);
                
                // æ¸…ç©ºç”»å¸ƒ
                canvasContext.clearRect(0, 0, canvasWidth, canvasHeight);
                
                // ç»˜åˆ¶æ³¢å½¢
                canvasContext.lineWidth = 2;
                canvasContext.strokeStyle = '#2563eb';
                canvasContext.beginPath();
                
                const sliceWidth = canvasWidth / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvasHeight / 2;
                    
                    if (i === 0) {
                        canvasContext.moveTo(x, y);
                    } else {
                        canvasContext.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                canvasContext.lineTo(canvasWidth, canvasHeight / 2);
                canvasContext.stroke();
                
                drawWaveform();
            });
        }

        // ================= å½•éŸ³æ§åˆ¶ =================
        async function stopRecording(save = true) {
            if (!isRecording) return;

            isRecording = false;
            recordingStartTime = null;
            stopRecordingTimer();

            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            // ä¿å­˜å½•éŸ³æ–‡ä»¶
            if (save && recordedChunks.length > 0) {
                const filename = generateFilename();
                const blob = new Blob(recordedChunks, { 
                    type: 'audio/webm;codecs=opus' 
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                log(`âœ… å½•éŸ³å·²ä¿å­˜ä¸º: ${filename}`);
            }

            recordedChunks = [];
            mediaRecorder = null;
            recordBtn.textContent = "å¼€å§‹å½•éŸ³";
            recordBtn.classList.remove('active');
            recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-active">å·²å¯åŠ¨</span>';
        }

        async function startRecording() {
            if (isRecording) return;

            try {
                // åˆ›å»ºå½•éŸ³ç›®æ ‡
                const dest = audioContext.createMediaStreamDestination();
                if (isFiltering && filterChain.length > 0) {
                    filterChain[filterChain.length-1].connect(dest);
                } else {
                    analyser.connect(dest);
                }

                // åˆå§‹åŒ–MediaRecorder
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                    ? 'audio/webm;codecs=opus' 
                    : 'audio/webm';
                
                mediaRecorder = new MediaRecorder(dest.stream, { 
                    mimeType,
                    audioBitsPerSecond: 128000 
                });

                // å¤„ç†å½•éŸ³æ•°æ®
                recordedChunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.onerror = (e) => {
                    log("âš ï¸ å½•éŸ³é”™è¯¯: " + e.error);
                    stopRecording(false);
                };

                // å¼€å§‹å½•éŸ³
                mediaRecorder.start(100);
                recordingStartTime = Date.now();
                memoryGuardTimer = setInterval(() => {
                    checkMemoryPressure();
                    updateRecordingTimer();
                }, 500);

                isRecording = true;
                recordBtn.textContent = "åœæ­¢å½•éŸ³";
                recordBtn.classList.add('active');
                recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-recording">æ­£åœ¨å½•éŸ³</span>';
                log("ğŸ™ï¸ å½•éŸ³å·²å¼€å§‹ï¼ˆæµå¼å†™å…¥ Â· è‡ªåŠ¨ä¿æŠ¤ï¼‰");

            } catch (err) {
                log("âŒ å½•éŸ³å¯åŠ¨å¤±è´¥: " + err.message);
                console.error(err);
            }
        }

        // ================= éŸ³é¢‘æ§åˆ¶ =================
        async function startAudio() {
            try {
                log("æ­£åœ¨å¯åŠ¨éŸ³é¢‘...");

                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 44100
                    });
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // åˆ›å»ºéŸ³é¢‘è¾“å‡ºå…ƒç´ ï¼ˆç”¨äºè®¾ç½®æ‰¬å£°å™¨ï¼‰
                audioOutputElement = new Audio();
                
                // è®¾ç½®è¾“å‡ºè®¾å¤‡
                if (currentOutputDeviceId && currentOutputDeviceId !== 'default') {
                    await setAudioOutputDevice(currentOutputDeviceId);
                }

                // è¯·æ±‚éº¦å…‹é£æµ
                const constraints = {
                    audio: {
                        deviceId: currentInputDeviceId === 'default' ? undefined : { exact: currentInputDeviceId },
                        sampleRate: 44100,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                sourceNode = audioContext.createMediaStreamSource(stream);

                // åˆå§‹åŒ–ä¸»å¢ç›ŠèŠ‚ç‚¹
                if (!masterGainNode) {
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = 1.0;
                    masterGainNode.connect(audioContext.destination);
                }

                // æ„å»ºéŸ³é¢‘å›¾ï¼ˆåˆå§‹ç¦ç”¨é™å™ªï¼‰
                buildAudioGraph(false);

                // æ›´æ–°UIçŠ¶æ€
                startBtn.disabled = true;
                startBtn.textContent = "âœ… éŸ³é¢‘è¿è¡Œä¸­";
                stopBtn.disabled = false;
                filterBtn.disabled = false;
                recordBtn.disabled = false;
                inputSelect.disabled = true;
                outputSelect.disabled = true;
                recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-active">å·²å¯åŠ¨</span>';
                log("âœ… éŸ³é¢‘å·²å¯åŠ¨ï¼ï¼ˆå¼ºé™å™ªæ¨¡å¼ï¼‰");

            } catch (err) {
                log("âŒ éº¦å…‹é£é”™è¯¯: " + err.message);
                alert("æ— æ³•è®¿é—®éº¦å…‹é£: " + err.message);
                
                // æ¸…ç†èµ„æº
                if (audioContext) await audioContext.close();
                audioContext = null;
                stream = null;
                sourceNode = null;
                
                // é‡ç½®UI
                startBtn.disabled = false;
                startBtn.textContent = "å¼€å§‹éŸ³é¢‘";
            }
        }

        async function stopAllAudio() {
            // åœæ­¢å½•éŸ³
            if (isRecording) {
                await stopRecording(false);
            }

            // åœæ­¢FFTç»˜åˆ¶
            if (fftAnimationId) {
                cancelAnimationFrame(fftAnimationId);
                fftAnimationId = null;
            }

            // åœæ­¢åª’ä½“æµ
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }

            // å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (audioContext) {
                try { await audioContext.close(); } catch (e) {}
                audioContext = null;
            }

            // æ¸…ç†éŸ³é¢‘è¾“å‡ºå…ƒç´ 
            if (audioOutputElement) {
                audioOutputElement.pause();
                audioOutputElement.srcObject = null;
                audioOutputElement = null;
            }

            // é‡ç½®èŠ‚ç‚¹
            sourceNode = null;
            analyser = null;
            masterGainNode = null;
            compressorNode = null;
            filterChain.forEach(node => { try { node.disconnect(); } catch (e) {} });
            filterChain = [];
            isFiltering = false;

            // é‡ç½®UI
            startBtn.disabled = false;
            startBtn.textContent = "å¼€å§‹éŸ³é¢‘";
            stopBtn.disabled = true;
            filterBtn.disabled = true;
            filterBtn.classList.remove('active');
            filterBtn.textContent = "å¯ç”¨é™å™ª";
            recordBtn.disabled = true;
            recordBtn.classList.remove('active');
            recordBtn.textContent = "å¼€å§‹å½•éŸ³";
            inputSelect.disabled = false;
            outputSelect.disabled = false;
            recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-inactive">æœªå¯åŠ¨</span>';
            noiseBadge.innerHTML = '<span class="badge-inactive">é™å™ªå·²å…³é—­</span>';
            stopRecordingTimer();
            log("âœ… éŸ³é¢‘å·²å…³é—­");
        }

        // ================= äº‹ä»¶ç»‘å®š =================
        document.addEventListener('DOMContentLoaded', async () => {
            // åˆå§‹åŒ–ç”»å¸ƒ
            initCanvas();
            
            // æ›´æ–°æ»‘å—æ˜¾ç¤º
            strengthValue.textContent = `${noiseReductionStrength.value}%`;
            gainValue.textContent = `${(gainSlider.value / 100).toFixed(1)}x`;

            // é™å™ªå¼ºåº¦æ»‘å—
            noiseReductionStrength.addEventListener('input', () => {
                strengthValue.textContent = `${noiseReductionStrength.value}%`;
                if (isFiltering && filterChain.length > 0) {
                    // æ›´æ–°é™·æ³¢æ»¤æ³¢å™¨çš„Qå€¼
                    notchFreqs.forEach((freq, index) => {
                        let qValue;
                        if (index === 0) {
                            qValue = Q_BASE * (noiseReductionStrength.value / 100);
                        } else if (index < 6) {
                            qValue = Q_HARMONIC * (noiseReductionStrength.value / 100);
                        } else {
                            qValue = Q_NARROW * (noiseReductionStrength.value / 100);
                        }
                        filterChain[index + 1].Q.value = qValue;
                    });
                }
            });

            // å¢ç›Šæ»‘å—
            gainSlider.addEventListener('input', () => {
                const g = gainSlider.value / 100;
                gainValue.textContent = g.toFixed(1) + 'x';
                
                if (audioContext) {
                    if (isFiltering && filterChain.length > 0) {
                        // æ›´æ–°æ»¤æ³¢é“¾ä¸­çš„å¢ç›Š
                        filterChain[filterChain.length - 2].gain.value = g;
                        filterChain[filterChain.length - 3].gain.value = g - 1;
                    } else if (masterGainNode) {
                        masterGainNode.gain.value = g;
                    }
                }
            });

            // è®¾å¤‡é€‰æ‹©å˜æ›´
            inputSelect.onchange = () => {
                currentInputDeviceId = inputSelect.value || 'default';
                localStorage.setItem('audioInputDeviceId', currentInputDeviceId);
            };

            outputSelect.onchange = () => {
                if (outputSelect.disabled) return;
                currentOutputDeviceId = outputSelect.value || 'default';
                localStorage.setItem('audioOutputDeviceId', currentOutputDeviceId);
            };

            // æŒ‰é’®äº‹ä»¶
            startBtn.addEventListener('click', startAudio);
            stopBtn.addEventListener('click', stopAllAudio);
            
            filterBtn.addEventListener('click', () => {
                isFiltering = !isFiltering;
                filterBtn.classList.toggle('active', isFiltering);
                filterBtn.textContent = isFiltering ? "å…³é—­é™å™ª" : "å¯ç”¨é™å™ª";
                if (audioContext) {
                    buildAudioGraph(isFiltering);
                }
            });
            
            recordBtn.addEventListener('click', async () => {
                if (isRecording) {
                    await stopRecording(true);
                } else {
                    await startRecording();
                }
            });

            // åˆå§‹åŒ–è®¾å¤‡åˆ—è¡¨
            try {
                // è¯·æ±‚ä¸´æ—¶æƒé™ä»¥æšä¸¾è®¾å¤‡
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                tempStream.getTracks().forEach(track => track.stop());
                await enumerateDevices();
            } catch (err) {
                log("âš ï¸ éœ€è¦éº¦å…‹é£æƒé™æ‰èƒ½æšä¸¾è®¾å¤‡");
                enumerateDevices(); // å³ä½¿æ²¡æœ‰æƒé™ä¹Ÿå°è¯•æšä¸¾
            }

            // ç›‘å¬è®¾å¤‡å˜åŒ–
            navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);
        });
    </script>
</body>
</html>
