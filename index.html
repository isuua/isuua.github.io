<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ¤ æ™ºèƒ½é™å™ªå½•éŸ³æœºï¼ˆè°±å‡æ³•ï¼‰- iOSé€‚é…ç‰ˆ</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --secondary: #64748b;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --background: #1a1a1a;
            --card: #242424;
            --border: #333;
            --text: #eee;
            --text-light: #999;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --radius: 8px;
            --transition: all 0.2s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        body {
            background-color: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 1rem;
            line-height: 1.5;
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        .card {
            background: var(--card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            border: 1px solid var(--border);
        }

        h1 {
            text-align: center;
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--primary);
        }

        .subtitle {
            text-align: center;
            color: var(--text-light);
            margin-bottom: 2rem;
            font-size: 0.9rem;
        }

        .device-selectors {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 15px 0;
        }

        select, input[type="number"], button, .file-label {
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            background: #444;
            color: white;
            cursor: pointer;
            font-size: 16px;
            min-width: 180px;
            -webkit-appearance: none;
            appearance: none;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }

        input[type="number"] {
            width: auto;
            min-width: 80px;
            text-align: center;
            background: #333;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
        }

        .btn {
            border: none;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-width: 140px;
            padding: 12px 20px;
            font-size: 16px;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-hover);
        }

        .btn-success {
            background-color: var(--success);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger);
            color: white;
        }

        .btn-warning {
            background-color: var(--warning);
            color: white;
        }

        .btn:disabled {
            background: #333;
            color: #777;
            cursor: not-allowed;
        }

        .btn.active {
            background: #1e88e5;
        }

        .waveform-container {
            width: 100%;
            height: 200px;
            background-color: #000;
            border-radius: var(--radius);
            overflow: hidden;
            margin: 1.5rem 0;
            position: relative;
        }

        #waveform {
            width: 100%;
            height: 100%;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background-color: var(--card);
            border-radius: var(--radius);
            margin-bottom: 1rem;
            border: 1px solid var(--border);
            flex-wrap: wrap;
            gap: 10px;
        }

        .status {
            font-weight: 500;
        }

        .status-active {
            color: var(--success);
        }

        .status-inactive {
            color: var(--text-light);
        }

        .status-recording {
            color: var(--danger);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .timer {
            font-family: monospace;
            font-size: 1.1rem;
        }

        .settings {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 999px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .badge-active {
            background-color: rgba(16, 185, 129, 0.2);
            color: var(--success);
        }

        .badge-inactive {
            background-color: rgba(100, 116, 139, 0.2);
            color: var(--text-light);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 180px;
            width: 100%;
            max-width: 300px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #444;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        #log {
            color: #ffcc00;
            font-size: 12px;
            margin-top: 10px;
            min-height: 20px;
            text-align: center;
        }

        /* iOSé€‚é… - å™ªå£°å½•åˆ¶æ›¿ä»£æ–¹æ¡ˆ */
        .noise-recorder-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
            align-items: center;
        }

        .noise-record-btn {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            min-width: 200px;
        }

        .noise-record-btn.recording {
            background-color: #ef4444;
        }

        .noise-recording-status {
            color: #999;
            font-size: 14px;
            margin-top: 5px;
        }

        .sample-duration-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 180px;
            width: 100%;
            max-width: 300px;
        }

        .advanced-settings {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
        }

        /* éšè—æ–‡ä»¶ä¸Šä¼ ï¼ˆiOSä¸æ”¯æŒï¼‰ */
        .noise-file-upload {
            display: none;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 0.5rem;
                align-items: flex-start;
            }
            
            .slider-container, .sample-duration-container {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ æ™ºèƒ½é™å™ªå½•éŸ³æœºï¼ˆè°±å‡æ³•ï¼‰</h1>
        <p class="subtitle">iOS Chromeé€‚é…ç‰ˆ | å®æ—¶è°±å‡æ³•é™å™ª | æ³¢å½¢å¯è§†åŒ– | M4Aæ ¼å¼</p>

        <!-- è®¾å¤‡é€‰æ‹©åŒº -->
        <div class="card">
            <div class="device-selectors">
                <select id="inputSelect" disabled>
                    <option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>
                </select>
                <select id="outputSelect" disabled>
                    <option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>
                </select>
            </div>

            <!-- iOSé€‚é…ï¼šå™ªå£°å½•åˆ¶æ›¿ä»£æ–¹æ¡ˆ -->
            <div class="noise-recorder-section">
                <button id="recordNoiseBtn" class="noise-record-btn" disabled>å½•åˆ¶å™ªå£°æ ·æœ¬</button>
                <div id="noiseRecordingStatus" class="noise-recording-status">ç‚¹å‡»å½•åˆ¶èƒŒæ™¯å™ªå£°ï¼ˆå»ºè®®3-5ç§’ï¼‰</div>
            </div>

            <!-- éšè—çš„æ–‡ä»¶ä¸Šä¼ ï¼ˆiOSä¸æ”¯æŒï¼‰ -->
            <div class="noise-file-upload">
                <input type="file" id="noiseFileInput" accept="audio/*" title="é€‰æ‹©å™ªå£°éŸ³é¢‘æ–‡ä»¶">
                <button id="loadNoiseBtn" class="btn btn-warning" disabled>åŠ è½½å™ªå£°æ ·æœ¬</button>
            </div>

            <!-- è®¾ç½®åŒº -->
            <div class="settings">
                <div class="slider-container">
                    <label>é™å™ªå¼ºåº¦:</label>
                    <input type="range" id="noise-reduction-strength" min="0" max="100" value="70" />
                    <span id="strength-value">70%</span>
                </div>
                <div class="sample-duration-container">
                    <label>å™ªå£°é‡‡æ ·æ—¶é•¿:</label>
                    <input type="range" id="noise-sample-duration" min="0.1" max="10" step="0.1" value="3" />
                    <span id="sample-duration-value">3s</span>
                </div>
                <div class="slider-container">
                    <label>äººå£°å¢ç›Š:</label>
                    <input type="range" id="gainSlider" min="0" max="300" value="150" />
                    <span id="gainValue">1.5x</span>
                </div>
                <div class="slider-container">
                    <label>æœ€å¤§æ—¶é•¿(ç§’):</label>
                    <input type="number" id="maxDurationInput" min="0" max="7200" value="0" />
                </div>
            </div>

            <!-- é«˜çº§è®¾ç½® -->
            <div class="settings advanced-settings">
                <div class="slider-container">
                    <label>å™ªå£°é˜ˆå€¼:</label>
                    <input type="range" id="noise-threshold" min="0" max="100" value="10" />
                    <span id="threshold-value">10%</span>
                </div>
                <div class="slider-container">
                    <label>é¢‘è°±å¹³æ»‘:</label>
                    <input type="range" id="spectrum-smoothing" min="0" max="50" value="20" />
                    <span id="smoothing-value">20%</span>
                </div>
                <div class="slider-container">
                    <label>è¿‡å‡å› å­:</label>
                    <input type="range" id="over-subtraction" min="0" max="100" value="15" />
                    <span id="over-sub-value">15%</span>
                </div>
            </div>

            <!-- çŠ¶æ€ä¿¡æ¯ -->
            <div class="status-bar">
                <div class="status-container">
                    <span class="status" id="recorder-status">çŠ¶æ€: <span class="status-inactive">æœªå¯åŠ¨</span></span>
                    <span class="badge" id="noise-badge" style="margin-left: 1rem;">
                        <span class="badge-inactive">é™å™ªå·²å…³é—­</span>
                    </span>
                </div>
                <div class="timer" id="recording-timer">00:00:00</div>
            </div>
            
            <div id="log">å°±ç»ª (è¾“å‡ºæ ¼å¼: M4A) | iOS Chromeé€‚é…ç‰ˆ</div>

            <!-- æ§åˆ¶æŒ‰é’® -->
            <div class="controls">
                <button id="startBtn" class="btn btn-primary">å¼€å§‹éŸ³é¢‘</button>
                <button id="stopBtn" class="btn btn-danger" disabled>å…³é—­éŸ³é¢‘</button>
                <button id="filterBtn" class="btn btn-warning" disabled>å¯ç”¨é™å™ª</button>
                <button id="recordBtn" class="btn btn-success" disabled>å¼€å§‹å½•éŸ³</button>
                <button id="calibrateBtn" class="btn btn-primary" disabled>æ ¡å‡†å™ªå£°</button>
            </div>
        </div>

        <!-- æ³¢å½¢å¯è§†åŒ–åŒºåŸŸ -->
        <div class="card">
            <h3 style="margin-bottom: 1rem; text-align: center;">å®æ—¶å£°éŸ³æ³¢å½¢</h3>
            <div class="waveform-container">
                <canvas id="waveform"></canvas>
            </div>
        </div>
    </div>

    <script>
        // ================= å…¨å±€çŠ¶æ€ =================
        const logEl = document.getElementById('log');
        let audioContext = null;
        let stream = null;
        let sourceNode = null;
        let analyser = null;
        let masterGainNode = null;
        let isFiltering = false;
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let currentInputDeviceId = localStorage.getItem('audioInputDeviceId') || 'default';
        let currentOutputDeviceId = localStorage.getItem('audioOutputDeviceId') || 'default';
        let fftAnimationId = null;
        let recordingStartTime = null;
        let memoryGuardTimer = null;
        let recordingTimerInterval = null;
        let audioOutputElement = null;
        
        // è°±å‡æ³•é™å™ªç›¸å…³
        let noiseSampleBuffer = null;
        let noiseSpectrum = null;
        let denoiseProcessor = null;
        let isRecordingNoise = false;
        let noiseRecorder = null;
        let noiseRecordedChunks = [];
        
        // é™å™ªå‚æ•°
        const FFT_SIZE = 1024;
        const HOP_SIZE = FFT_SIZE / 2;
        const MAX_ESTIMATED_MEMORY_BYTES = 80 * 1024 * 1024;
        
        // å¯è°ƒå‚æ•°
        let noiseThreshold = 0.1;
        let spectrumSmoothing = 0.2;
        let overSubtractionFactor = 0.15;

        // DOM å…ƒç´ 
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const filterBtn = document.getElementById('filterBtn');
        const recordBtn = document.getElementById('recordBtn');
        const gainSlider = document.getElementById('gainSlider');
        const gainValue = document.getElementById('gainValue');
        const noiseReductionStrength = document.getElementById('noise-reduction-strength');
        const strengthValue = document.getElementById('strength-value');
        const noiseSampleDuration = document.getElementById('noise-sample-duration');
        const sampleDurationValue = document.getElementById('sample-duration-value');
        const maxDurationInput = document.getElementById('maxDurationInput');
        const waveformCanvas = document.getElementById('waveform');
        const recorderStatus = document.getElementById('recorder-status');
        const noiseBadge = document.getElementById('noise-badge');
        const recordingTimer = document.getElementById('recording-timer');
        const calibrateBtn = document.getElementById('calibrateBtn');
        const recordNoiseBtn = document.getElementById('recordNoiseBtn');
        const noiseRecordingStatus = document.getElementById('noiseRecordingStatus');
        
        // é«˜çº§å‚æ•°æ§ä»¶
        const noiseThresholdSlider = document.getElementById('noise-threshold');
        const thresholdValue = document.getElementById('threshold-value');
        const spectrumSmoothingSlider = document.getElementById('spectrum-smoothing');
        const smoothingValue = document.getElementById('smoothing-value');
        const overSubtractionSlider = document.getElementById('over-subtraction');
        const overSubValue = document.getElementById('over-sub-value');
        
        let canvasContext;
        let canvasWidth;
        let canvasHeight;

        // ================= å·¥å…·å‡½æ•° =================
        function log(msg) {
            console.log(msg);
            logEl.textContent = msg;
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${hours}:${minutes}:${secs}`;
        }

        function updateRecordingTimer() {
            if (!recordingStartTime) return;
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimer.textContent = formatTime(elapsed);
        }

        function clearAllRecordingTimers() {
            if (memoryGuardTimer) {
                clearInterval(memoryGuardTimer);
                memoryGuardTimer = null;
            }
            if (recordingTimerInterval) {
                clearInterval(recordingTimerInterval);
                recordingTimerInterval = null;
            }
            recordingTimer.textContent = '00:00:00';
            recordingStartTime = null;
        }

        function estimateRecordedSize() {
            if (!recordedChunks.length) return 0;
            return recordedChunks.reduce((total, chunk) => total + chunk.size, 0);
        }

        function checkMemoryPressure() {
            if (!isRecording || !recordingStartTime) return;

            const maxDurationSeconds = parseInt(maxDurationInput.value) || 0;

            if (maxDurationSeconds > 0) {
                const elapsedSeconds = (Date.now() - recordingStartTime) / 1000;
                if (elapsedSeconds >= maxDurationSeconds) {
                    log(`[è‡ªåŠ¨åœæ­¢] è¾¾åˆ°æœ€å¤§æ—¶é•¿: ${maxDurationSeconds}s`);
                    stopRecording(true).then(() => {
                        alert(`å½•éŸ³å·²è‡ªåŠ¨åœæ­¢ï¼ˆè¾¾åˆ°æœ€å¤§æ—¶é•¿ ${maxDurationSeconds} ç§’ï¼‰`);
                    });
                    return;
                }
            }

            if (maxDurationSeconds === 0) {
                const estimated = estimateRecordedSize();
                if (estimated > MAX_ESTIMATED_MEMORY_BYTES * 0.9) {
                    log(`[è‡ªåŠ¨åœæ­¢] å†…å­˜é™åˆ¶å·²è¾¾: ${(estimated / 1024 / 1024).toFixed(1)}MB`);
                    stopRecording(true).then(() => {
                        alert(`å½•éŸ³å·²è‡ªåŠ¨åœæ­¢ï¼ˆå†…å­˜å ç”¨è¾¾åˆ°é˜ˆå€¼ï¼‰`);
                    });
                }
            }
        }

        function generateFilename() {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            return `recording_${timestamp}.m4a`;
        }

        function getSupportedM4aFormat() {
            const formats = [
                'audio/mp4;codecs=mp4a.40.2',
                'audio/mp4;codecs=aac',
                'audio/aac;codecs=aac',
                'audio/webm;codecs=opus'
            ];
            
            for (const format of formats) {
                if (MediaRecorder.isTypeSupported(format)) {
                    log(`âœ… ä½¿ç”¨éŸ³é¢‘æ ¼å¼: ${format}`);
                    return format;
                }
            }
            
            log(`âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒM4Aæ ¼å¼ï¼Œé™çº§ä¸ºwebm`);
            return 'audio/webm;codecs=opus';
        }

        // ================= iOSé€‚é…ï¼šå½•åˆ¶å™ªå£°æ ·æœ¬ =================
        async function startRecordingNoise() {
            if (!audioContext || !stream) {
                log("âŒ è¯·å…ˆå¯åŠ¨éŸ³é¢‘");
                return;
            }
            
            if (isRecordingNoise) {
                await stopRecordingNoise();
                return;
            }
            
            try {
                isRecordingNoise = true;
                recordNoiseBtn.textContent = "åœæ­¢å½•åˆ¶å™ªå£°";
                recordNoiseBtn.classList.add('recording');
                noiseRecordingStatus.textContent = "æ­£åœ¨å½•åˆ¶èƒŒæ™¯å™ªå£°...è¯·ä¿æŒç¯å¢ƒå®‰é™";
                
                // åˆ›å»ºå™ªå£°å½•åˆ¶ç›®æ ‡
                const dest = audioContext.createMediaStreamDestination();
                sourceNode.connect(dest);
                
                // åˆå§‹åŒ–å™ªå£°å½•åˆ¶å™¨
                const mimeType = getSupportedM4aFormat();
                noiseRecorder = new MediaRecorder(dest.stream, {
                    mimeType: mimeType,
                    audioBitsPerSecond: 128000
                });
                
                noiseRecordedChunks = [];
                noiseRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0 && isRecordingNoise) {
                        noiseRecordedChunks.push(e.data);
                    }
                };
                
                noiseRecorder.onerror = (e) => {
                    log(`âš ï¸ å™ªå£°å½•åˆ¶é”™è¯¯: ${e.error}`);
                    stopRecordingNoise().catch(err => console.error(err));
                };
                
                noiseRecorder.onstop = async () => {
                    if (noiseRecordedChunks.length > 0) {
                        await processRecordedNoise();
                    }
                };
                
                // å¼€å§‹å½•åˆ¶
                noiseRecorder.start(100);
                
                // è‡ªåŠ¨åœæ­¢ï¼ˆæ ¹æ®è®¾ç½®çš„æ—¶é•¿ï¼‰
                const sampleDuration = parseFloat(noiseSampleDuration.value) * 1000;
                setTimeout(() => {
                    if (isRecordingNoise) {
                        stopRecordingNoise();
                    }
                }, sampleDuration);
                
                log("ğŸ™ï¸ å¼€å§‹å½•åˆ¶å™ªå£°æ ·æœ¬");
                
            } catch (err) {
                log(`âŒ å¯åŠ¨å™ªå£°å½•åˆ¶å¤±è´¥: ${err.message}`);
                isRecordingNoise = false;
                recordNoiseBtn.textContent = "å½•åˆ¶å™ªå£°æ ·æœ¬";
                recordNoiseBtn.classList.remove('recording');
                noiseRecordingStatus.textContent = "å½•åˆ¶å¤±è´¥: " + err.message;
            }
        }

        async function stopRecordingNoise() {
            if (!isRecordingNoise || !noiseRecorder) {
                return;
            }
            
            try {
                isRecordingNoise = false;
                recordNoiseBtn.textContent = "å½•åˆ¶å™ªå£°æ ·æœ¬";
                recordNoiseBtn.classList.remove('recording');
                
                if (noiseRecorder.state === 'recording') {
                    noiseRecorder.stop();
                }
                
                noiseRecordingStatus.textContent = "å™ªå£°å½•åˆ¶å®Œæˆï¼Œæ­£åœ¨åˆ†æ...";
                
            } catch (err) {
                log(`âŒ åœæ­¢å™ªå£°å½•åˆ¶å¤±è´¥: ${err.message}`);
                noiseRecordingStatus.textContent = "å½•åˆ¶å¤±è´¥: " + err.message;
            }
        }

        async function processRecordedNoise() {
            if (!audioContext || noiseRecordedChunks.length === 0) {
                noiseRecordingStatus.textContent = "å™ªå£°æ ·æœ¬ä¸ºç©ºï¼Œè¯·é‡æ–°å½•åˆ¶";
                return;
            }
            
            try {
                log("æ­£åœ¨åˆ†æå½•åˆ¶çš„å™ªå£°æ ·æœ¬...");
                noiseRecordingStatus.textContent = "æ­£åœ¨åˆ†æå™ªå£°ç‰¹å¾...";
                
                // åˆ›å»ºBlobå¹¶è§£ç 
                const mimeType = noiseRecorder.mimeType || 'audio/mp4';
                const blob = new Blob(noiseRecordedChunks, { type: mimeType });
                const arrayBuffer = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsArrayBuffer(blob);
                });
                
                // è§£ç éŸ³é¢‘
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // è½¬æ¢ä¸ºå•å£°é“
                const monoBuffer = audioContext.createBuffer(1, audioBuffer.length, audioBuffer.sampleRate);
                const sourceData = audioBuffer.getChannelData(0);
                const targetData = monoBuffer.getChannelData(0);
                targetData.set(sourceData);
                
                // åˆ†æå™ªå£°ç‰¹å¾
                const noiseData = monoBuffer.getChannelData(0);
                const noiseFFT = new Array(FFT_SIZE / 2).fill(0);
                const window = hanningWindow(FFT_SIZE);
                const fft = new FFT(FFT_SIZE, audioContext.sampleRate);
                
                // åˆ†å—åˆ†æå™ªå£°
                let count = 0;
                for (let i = 0; i < noiseData.length - FFT_SIZE; i += HOP_SIZE) {
                    const block = new Float32Array(FFT_SIZE);
                    for (let j = 0; j < FFT_SIZE; j++) {
                        block[j] = noiseData[i + j] * window[j];
                    }
                    
                    fft.forward(block);
                    
                    for (let j = 0; j < FFT_SIZE / 2; j++) {
                        const power = fft.real[j] * fft.real[j] + fft.imag[j] * fft.imag[j];
                        noiseFFT[j] += power;
                    }
                    count++;
                }
                
                // å½’ä¸€åŒ–
                for (let j = 0; j < FFT_SIZE / 2; j++) {
                    noiseFFT[j] /= count;
                }
                
                noiseSampleBuffer = monoBuffer;
                noiseSpectrum = noiseFFT;
                
                noiseRecordingStatus.textContent = `å™ªå£°æ ·æœ¬åˆ†æå®Œæˆ (${(audioBuffer.duration).toFixed(2)}ç§’)`;
                log(`âœ… å™ªå£°æ ·æœ¬åˆ†æå®Œæˆ (${count}ä¸ªåˆ†æå—)`);
                
                // å¦‚æœé™å™ªå·²å¼€å¯ï¼Œé‡æ–°æ„å»ºéŸ³é¢‘å›¾
                if (isFiltering && audioContext) {
                    await buildAudioGraph(true);
                }
                
            } catch (err) {
                log(`âŒ å¤„ç†å™ªå£°æ ·æœ¬å¤±è´¥: ${err.message}`);
                noiseRecordingStatus.textContent = "åˆ†æå¤±è´¥: " + err.message;
            }
        }

        // ================= è°±å‡æ³•æ ¸å¿ƒå‡½æ•° =================
        function hanningWindow(size) {
            const window = new Float32Array(size);
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
            }
            return window;
        }

        class FFT {
            constructor(size, sampleRate) {
                this.size = size;
                this.sampleRate = sampleRate;
                this.real = new Float32Array(size);
                this.imag = new Float32Array(size);
                this.spectrum = new Float32Array(size);
                this.prevSpectrum = new Float32Array(size/2).fill(0);
                
                this.twiddle = new Array(size / 2);
                for (let i = 0; i < size / 2; i++) {
                    const angle = -2 * Math.PI * i / size;
                    this.twiddle[i] = {
                        re: Math.cos(angle),
                        im: Math.sin(angle)
                    };
                }
            }
            
            forward(input) {
                const n = this.size;
                const real = this.real;
                const imag = this.imag;
                
                for (let i = 0; i < n; i++) {
                    real[i] = input[i] || 0;
                    imag[i] = 0;
                }
                
                let j = 0;
                for (let i = 1; i < n; i++) {
                    let bit = n >> 1;
                    for (; j >= bit; bit >>= 1) {
                        j -= bit;
                    }
                    j += bit;
                    if (i < j) {
                        [real[i], real[j]] = [real[j], real[i]];
                        [imag[i], imag[j]] = [imag[j], imag[i]];
                    }
                }
                
                for (let len = 2; len <= n; len <<= 1) {
                    const halfLen = len >> 1;
                    const step = n / len;
                    
                    for (let i = 0; i < n; i += len) {
                        for (let j = 0; j < halfLen; j++) {
                            const k = (j * step) % (n / 2);
                            const tRe = real[i + j + halfLen] * this.twiddle[k].re + imag[i + j + halfLen] * this.twiddle[k].im;
                            const tIm = imag[i + j + halfLen] * this.twiddle[k].re - real[i + j + halfLen] * this.twiddle[k].im;
                            
                            real[i + j + halfLen] = real[i + j] - tRe;
                            imag[i + j + halfLen] = imag[i + j] - tIm;
                            real[i + j] += tRe;
                            imag[i + j] += tIm;
                        }
                    }
                }
            }
            
            inverse() {
                const n = this.size;
                const real = this.real;
                const imag = this.imag;
                
                for (let i = 0; i < n; i++) {
                    imag[i] = -imag[i];
                }
                
                this.forward(real);
                
                for (let i = 0; i < n; i++) {
                    this.spectrum[i] = real[i] / n;
                    imag[i] = -imag[i] / n;
                }
            }
            
            smoothSpectrum(spectrum, smoothingFactor) {
                const smoothed = new Float32Array(spectrum.length);
                for (let i = 0; i < spectrum.length; i++) {
                    smoothed[i] = (1 - smoothingFactor) * spectrum[i] + smoothingFactor * this.prevSpectrum[i];
                    this.prevSpectrum[i] = smoothed[i];
                }
                return smoothed;
            }
        }

        async function collectNoiseSample() {
            if (!audioContext || !sourceNode) return;
            
            log("æ­£åœ¨é‡‡é›†åº•å™ªæ ·æœ¬...");
            
            const sampleDuration = parseFloat(noiseSampleDuration.value);
            const sampleLength = Math.floor(sampleDuration * audioContext.sampleRate);
            const sampleBuffer = audioContext.createBuffer(1, sampleLength, audioContext.sampleRate);
            const sampleData = sampleBuffer.getChannelData(0);
            
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = FFT_SIZE;
            sourceNode.connect(analyser);
            
            const noiseData = new Float32Array(FFT_SIZE);
            const noiseFFT = new Array(FFT_SIZE / 2).fill(0);
            
            await new Promise(resolve => setTimeout(resolve, sampleDuration * 1000));
            
            for (let i = 0; i < sampleLength - FFT_SIZE; i += HOP_SIZE) {
                analyser.getFloatFrequencyData(noiseData);
                for (let j = 0; j < FFT_SIZE / 2; j++) {
                    noiseFFT[j] += Math.pow(10, noiseData[j] / 20);
                }
            }
            
            for (let j = 0; j < FFT_SIZE / 2; j++) {
                noiseFFT[j] /= (sampleLength / HOP_SIZE);
            }
            
            noiseSampleBuffer = sampleBuffer;
            noiseSpectrum = noiseFFT;
            
            analyser.disconnect();
            log(`âœ… åº•å™ªæ ·æœ¬é‡‡é›†å®Œæˆï¼ˆ${sampleDuration}ç§’ï¼‰`);
        }

        async function calibrateNoise() {
            if (!audioContext || !sourceNode) {
                log("âŒ è¯·å…ˆå¯åŠ¨éŸ³é¢‘");
                return;
            }
            
            log("ğŸ¯ å¼€å§‹å™ªå£°æ ¡å‡†...");
            filterBtn.disabled = true;
            recordBtn.disabled = true;
            
            try {
                const wasFiltering = isFiltering;
                if (wasFiltering) {
                    isFiltering = false;
                    await buildAudioGraph(false);
                }
                
                alert("è¯·ä¿æŒç¯å¢ƒå®‰é™ï¼Œæ­£åœ¨æ ¡å‡†èƒŒæ™¯å™ªå£°ï¼ˆ" + noiseSampleDuration.value + "ç§’ï¼‰");
                await collectNoiseSample();
                
                if (wasFiltering) {
                    isFiltering = true;
                    await buildAudioGraph(true);
                }
                
                log("âœ… å™ªå£°æ ¡å‡†å®Œæˆï¼");
                filterBtn.disabled = false;
                recordBtn.disabled = false;
                
            } catch (err) {
                log(`âŒ å™ªå£°æ ¡å‡†å¤±è´¥: ${err.message}`);
                filterBtn.disabled = false;
                recordBtn.disabled = false;
            }
        }

        function createSpectralSubtractionProcessor() {
            if (!audioContext || !noiseSpectrum) return null;
            
            const processor = audioContext.createScriptProcessor(1024, 1, 1);
            const fft = new FFT(FFT_SIZE, audioContext.sampleRate);
            const window = hanningWindow(FFT_SIZE);
            const overlapBuffer = new Float32Array(FFT_SIZE);
            const prevCleanSpectrum = new Float32Array(FFT_SIZE / 2).fill(0);
            
            processor.onaudioprocess = function(e) {
                const inputData = e.inputBuffer.getChannelData(0);
                const outputData = e.outputBuffer.getChannelData(0);
                const reductionStrength = parseFloat(noiseReductionStrength.value) / 100;
                const gain = parseFloat(gainSlider.value) / 100;
                
                outputData.fill(0);
                
                for (let i = 0; i < inputData.length - FFT_SIZE; i += HOP_SIZE) {
                    const block = new Float32Array(FFT_SIZE);
                    for (let j = 0; j < FFT_SIZE; j++) {
                        block[j] = (i + j < inputData.length) ? inputData[i + j] * window[j] : 0;
                    }
                    
                    fft.forward(block);
                    
                    for (let j = 0; j < FFT_SIZE / 2; j++) {
                        const signalPower = fft.real[j] * fft.real[j] + fft.imag[j] * fft.imag[j];
                        let noisePower = noiseSpectrum[j] * (1 + overSubtractionFactor);
                        noisePower *= reductionStrength;
                        
                        let cleanPower = signalPower - noisePower;
                        const minPower = signalPower * noiseThreshold;
                        cleanPower = Math.max(cleanPower, minPower);
                        
                        cleanPower = (1 - spectrumSmoothing) * cleanPower + spectrumSmoothing * prevCleanSpectrum[j];
                        prevCleanSpectrum[j] = cleanPower;
                        
                        const magnitude = Math.sqrt(cleanPower);
                        const phase = Math.atan2(fft.imag[j], fft.real[j]);
                        
                        fft.real[j] = magnitude * Math.cos(phase);
                        fft.imag[j] = magnitude * Math.sin(phase);
                        
                        if (j > 0 && j < FFT_SIZE / 2) {
                            fft.real[FFT_SIZE - j] = fft.real[j];
                            fft.imag[FFT_SIZE - j] = -fft.imag[j];
                        }
                    }
                    
                    fft.inverse();
                    
                    for (let j = 0; j < FFT_SIZE; j++) {
                        if (i + j < outputData.length) {
                            outputData[i + j] += (fft.spectrum[j] * window[j] / HOP_SIZE + overlapBuffer[j]) * gain;
                        }
                    }
                    
                    const copyLength = Math.min(FFT_SIZE, outputData.length - (i + HOP_SIZE));
                    overlapBuffer.set(outputData.slice(i + HOP_SIZE, i + HOP_SIZE + copyLength));
                }
                
                for (let i = Math.max(0, inputData.length - FFT_SIZE); i < inputData.length; i++) {
                    outputData[i] = inputData[i] * 0.5 * gain;
                }
            };
            
            return processor;
        }

        // ================= è®¾å¤‡å¤„ç† =================
        async function enumerateDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(d => d.kind === 'audioinput');
                const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

                inputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>';
                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `éº¦å…‹é£ ${inputSelect.children.length}`;
                    if (device.deviceId === currentInputDeviceId) option.selected = true;
                    inputSelect.appendChild(option);
                });

                if (typeof HTMLAudioElement.prototype.setSinkId === 'function') {
                    outputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>';
                    audioOutputs.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `æ‰¬å£°å™¨ ${outputSelect.children.length}`;
                        if (device.deviceId === currentOutputDeviceId) option.selected = true;
                        outputSelect.appendChild(option);
                    });
                    outputSelect.disabled = false;
                } else {
                    outputSelect.innerHTML = '<option>å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‰¬å£°å™¨é€‰æ‹©</option>';
                    outputSelect.disabled = true;
                }

                inputSelect.disabled = false;
                log("âœ… è®¾å¤‡åˆ—è¡¨å·²æ›´æ–°");
            } catch (err) {
                log("âŒ è®¾å¤‡æšä¸¾å¤±è´¥: " + err.message);
            }
        }

        async function setAudioOutputDevice(deviceId) {
            if (!audioOutputElement) {
                audioOutputElement = new Audio();
            }
            
            if (deviceId && deviceId !== 'default' && typeof audioOutputElement.setSinkId === 'function') {
                try {
                    await audioOutputElement.setSinkId(deviceId);
                    log(`âœ… è¾“å‡ºè®¾å¤‡å·²åˆ‡æ¢åˆ°: ${deviceId.substring(0, 8)}...`);
                } catch (err) {
                    log(`âš ï¸ åˆ‡æ¢è¾“å‡ºè®¾å¤‡å¤±è´¥: ${err.message}`);
                }
            }
        }

        // ================= ç”»å¸ƒåˆå§‹åŒ– =================
        function initCanvas() {
            canvasContext = waveformCanvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const container = waveformCanvas.parentElement;
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            waveformCanvas.width = canvasWidth * window.devicePixelRatio;
            waveformCanvas.height = canvasHeight * window.devicePixelRatio;
            canvasContext.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        // ================= éŸ³é¢‘å›¾æ„å»º =================
        async function buildAudioGraph(enableFilter) {
            if (fftAnimationId) {
                cancelAnimationFrame(fftAnimationId);
                fftAnimationId = null;
            }

            if (analyser) {
                try { analyser.disconnect(); } catch (e) {}
                analyser = null;
            }
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024;
            analyser.smoothingTimeConstant = 0.5;

            if (!masterGainNode) {
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.value = 1.0;
            }

            try { sourceNode.disconnect(); } catch (e) {}
            
            if (denoiseProcessor) {
                try { denoiseProcessor.disconnect(); } catch (e) {}
                denoiseProcessor = null;
            }

            if (enableFilter) {
                if (!noiseSpectrum) {
                    await collectNoiseSample();
                }
                
                denoiseProcessor = createSpectralSubtractionProcessor();
                if (denoiseProcessor) {
                    sourceNode.connect(denoiseProcessor);
                    denoiseProcessor.connect(analyser);
                    analyser.connect(masterGainNode);
                    noiseBadge.innerHTML = '<span class="badge-active">è°±å‡æ³•é™å™ªå·²å¼€å¯</span>';
                    log("âœ… è°±å‡æ³•é™å™ªå·²å¯ç”¨");
                } else {
                    sourceNode.connect(analyser);
                    analyser.connect(masterGainNode);
                    log("âš ï¸ é™å™ªå¤„ç†å™¨åˆ›å»ºå¤±è´¥ï¼Œä½¿ç”¨åŸå§‹éŸ³é¢‘");
                }
            } else {
                sourceNode.connect(analyser);
                analyser.connect(masterGainNode);
                noiseBadge.innerHTML = '<span class="badge-inactive">é™å™ªå·²å…³é—­</span>';
                log("âœ… é™å™ªå·²å…³é—­");
            }

            masterGainNode.connect(audioContext.destination);
            
            if (audioOutputElement && currentOutputDeviceId && currentOutputDeviceId !== 'default') {
                const dest = audioContext.createMediaStreamDestination();
                masterGainNode.connect(dest);
                audioOutputElement.srcObject = dest.stream;
                audioOutputElement.play().catch(e => log(`âš ï¸ æ’­æ”¾é”™è¯¯: ${e.message}`));
            }

            drawWaveform();
        }

        // ================= æ³¢å½¢ç»˜åˆ¶ =================
        function drawWaveform() {
            if (!analyser) return;
            
            fftAnimationId = requestAnimationFrame(() => {
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(dataArray);
                
                canvasContext.clearRect(0, 0, canvasWidth, canvasHeight);
                
                canvasContext.lineWidth = 2;
                canvasContext.strokeStyle = '#2563eb';
                canvasContext.beginPath();
                
                const sliceWidth = canvasWidth / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvasHeight / 2;
                    
                    if (i === 0) {
                        canvasContext.moveTo(x, y);
                    } else {
                        canvasContext.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                canvasContext.lineTo(canvasWidth, canvasHeight / 2);
                canvasContext.stroke();
                
                drawWaveform();
            });
        }

        // ================= å½•éŸ³æ§åˆ¶ =================
        async function stopRecording(save = true) {
            if (!isRecording || !mediaRecorder) {
                log("âš ï¸ æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„å½•éŸ³");
                return;
            }

            try {
                isRecording = false;
                recordBtn.disabled = true;
                recordBtn.textContent = "åœæ­¢ä¸­...";

                clearAllRecordingTimers();

                if (mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }

                if (save && recordedChunks.length > 0) {
                    const filename = generateFilename();
                    const mimeType = mediaRecorder.mimeType || 'audio/mp4';
                    const blob = new Blob(recordedChunks, { 
                        type: mimeType 
                    });
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    log(`âœ… å½•éŸ³å·²ä¿å­˜ (M4Aæ ¼å¼): ${filename}`);
                }

                recordedChunks = [];
                mediaRecorder = null;

                recordBtn.textContent = "å¼€å§‹å½•éŸ³";
                recordBtn.classList.remove('active');
                recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-active">å·²å¯åŠ¨</span>';
                recordBtn.disabled = false;

                log("âœ… å½•éŸ³å·²åœæ­¢");

            } catch (err) {
                log(`âŒ åœæ­¢å½•éŸ³å¤±è´¥: ${err.message}`);
                console.error("åœæ­¢å½•éŸ³é”™è¯¯:", err);
                
                isRecording = false;
                clearAllRecordingTimers();
                recordedChunks = [];
                mediaRecorder = null;
                
                recordBtn.textContent = "å¼€å§‹å½•éŸ³";
                recordBtn.classList.remove('active');
                recordBtn.disabled = false;
            }
        }

        async function startRecording() {
            if (isRecording || !audioContext || !analyser) {
                log("âš ï¸ æ— æ³•å¼€å§‹å½•éŸ³ï¼ˆéŸ³é¢‘æœªå¯åŠ¨æˆ–å·²æœ‰å½•éŸ³ï¼‰");
                return;
            }

            try {
                const dest = audioContext.createMediaStreamDestination();
                if (isFiltering && denoiseProcessor) {
                    denoiseProcessor.connect(dest);
                } else {
                    analyser.connect(dest);
                }

                const mimeType = getSupportedM4aFormat();
                
                mediaRecorder = new MediaRecorder(dest.stream, { 
                    mimeType: mimeType,
                    audioBitsPerSecond: 128000
                });

                recordedChunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0 && isRecording) {
                        recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.onerror = (e) => {
                    log(`âš ï¸ å½•éŸ³é”™è¯¯: ${e.error}`);
                    stopRecording(false).catch(err => console.error(err));
                };

                mediaRecorder.onstop = () => {
                    if (isRecording) {
                        stopRecording(true).catch(err => console.error(err));
                    }
                };

                mediaRecorder.start(100);
                isRecording = true;
                recordingStartTime = Date.now();
                
                memoryGuardTimer = setInterval(checkMemoryPressure, 500);
                recordingTimerInterval = setInterval(updateRecordingTimer, 1000);

                recordBtn.textContent = "åœæ­¢å½•éŸ³";
                recordBtn.classList.add('active');
                recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-recording">æ­£åœ¨å½•éŸ³ (M4A)</span>';
                log("ğŸ™ï¸ å½•éŸ³å·²å¼€å§‹ï¼ˆè°±å‡æ³•é™å™ªæ¨¡å¼ï¼Œè¾“å‡ºM4Aæ ¼å¼ï¼‰");

            } catch (err) {
                log(`âŒ å½•éŸ³å¯åŠ¨å¤±è´¥: ${err.message}`);
                console.error("å¯åŠ¨å½•éŸ³é”™è¯¯:", err);
                
                isRecording = false;
                clearAllRecordingTimers();
                recordedChunks = [];
                mediaRecorder = null;
            }
        }

        // ================= éŸ³é¢‘æ§åˆ¶ =================
        async function startAudio() {
            try {
                log("æ­£åœ¨å¯åŠ¨éŸ³é¢‘... (iOS Chromeé€‚é…ç‰ˆ)");

                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 44100
                    });
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                audioOutputElement = new Audio();
                
                if (currentOutputDeviceId && currentOutputDeviceId !== 'default') {
                    await setAudioOutputDevice(currentOutputDeviceId);
                }

                const constraints = {
                    audio: {
                        deviceId: currentInputDeviceId === 'default' ? undefined : { exact: currentInputDeviceId },
                        sampleRate: 44100,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                sourceNode = audioContext.createMediaStreamSource(stream);

                if (!masterGainNode) {
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = 1.0;
                    masterGainNode.connect(audioContext.destination);
                }

                await buildAudioGraph(false);

                startBtn.disabled = true;
                startBtn.textContent = "âœ… éŸ³é¢‘è¿è¡Œä¸­";
                stopBtn.disabled = false;
                filterBtn.disabled = false;
                recordBtn.disabled = false;
                calibrateBtn.disabled = false;
                recordNoiseBtn.disabled = false;
                inputSelect.disabled = true;
                outputSelect.disabled = true;
                recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-active">å·²å¯åŠ¨ (M4A)</span>';
                log("âœ… éŸ³é¢‘å·²å¯åŠ¨ï¼iOS Chromeé€‚é…ç‰ˆ");

            } catch (err) {
                log(`âŒ éº¦å…‹é£é”™è¯¯: ${err.message}`);
                alert("æ— æ³•è®¿é—®éº¦å…‹é£: " + err.message);
                
                if (audioContext) await audioContext.close();
                audioContext = null;
                stream = null;
                sourceNode = null;
                
                startBtn.disabled = false;
                startBtn.textContent = "å¼€å§‹éŸ³é¢‘";
            }
        }

        async function stopAllAudio() {
            log("æ­£åœ¨å…³é—­éŸ³é¢‘...");
            
            if (isRecording) {
                await stopRecording(false);
            }

            if (isRecordingNoise) {
                await stopRecordingNoise();
            }

            if (fftAnimationId) {
                cancelAnimationFrame(fftAnimationId);
                fftAnimationId = null;
            }

            clearAllRecordingTimers();

            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }

            if (audioContext) {
                try { await audioContext.close(); } catch (e) {}
                audioContext = null;
            }

            if (audioOutputElement) {
                audioOutputElement.pause();
                audioOutputElement.srcObject = null;
                audioOutputElement = null;
            }

            sourceNode = null;
            analyser = null;
            masterGainNode = null;
            noiseSampleBuffer = null;
            noiseSpectrum = null;
            if (denoiseProcessor) {
                try { denoiseProcessor.disconnect(); } catch (e) {}
                denoiseProcessor = null;
            }
            isFiltering = false;
            isRecording = false;
            isRecordingNoise = false;
            noiseRecorder = null;
            noiseRecordedChunks = [];

            startBtn.disabled = false;
            startBtn.textContent = "å¼€å§‹éŸ³é¢‘";
            stopBtn.disabled = true;
            filterBtn.disabled = true;
            filterBtn.classList.remove('active');
            filterBtn.textContent = "å¯ç”¨é™å™ª";
            recordBtn.disabled = true;
            calibrateBtn.disabled = true;
            recordNoiseBtn.disabled = true;
            recordNoiseBtn.textContent = "å½•åˆ¶å™ªå£°æ ·æœ¬";
            recordNoiseBtn.classList.remove('recording');
            noiseRecordingStatus.textContent = "ç‚¹å‡»å½•åˆ¶èƒŒæ™¯å™ªå£°ï¼ˆå»ºè®®3-5ç§’ï¼‰";
            inputSelect.disabled = false;
            outputSelect.disabled = false;
            recorderStatus.innerHTML = 'çŠ¶æ€: <span class="status-inactive">æœªå¯åŠ¨</span>';
            noiseBadge.innerHTML = '<span class="badge-inactive">é™å™ªå·²å…³é—­</span>';
            
            log("âœ… éŸ³é¢‘å·²å…³é—­");
        }

        // ================= äº‹ä»¶ç»‘å®š =================
        document.addEventListener('DOMContentLoaded', async () => {
            initCanvas();
            
            strengthValue.textContent = `${noiseReductionStrength.value}%`;
            sampleDurationValue.textContent = `${noiseSampleDuration.value}s`;
            gainValue.textContent = `${(gainSlider.value / 100).toFixed(1)}x`;
            thresholdValue.textContent = `${noiseThresholdSlider.value}%`;
            smoothingValue.textContent = `${spectrumSmoothingSlider.value}%`;
            overSubValue.textContent = `${overSubtractionSlider.value}%`;

            noiseReductionStrength.addEventListener('input', () => {
                strengthValue.textContent = `${noiseReductionStrength.value}%`;
            });
            
            noiseSampleDuration.addEventListener('input', () => {
                sampleDurationValue.textContent = `${noiseSampleDuration.value}s`;
            });

            gainSlider.addEventListener('input', () => {
                const g = gainSlider.value / 100;
                gainValue.textContent = g.toFixed(1) + 'x';
            });
            
            noiseThresholdSlider.addEventListener('input', () => {
                noiseThreshold = parseFloat(noiseThresholdSlider.value) / 100;
                thresholdValue.textContent = `${noiseThresholdSlider.value}%`;
            });
            
            spectrumSmoothingSlider.addEventListener('input', () => {
                spectrumSmoothing = parseFloat(spectrumSmoothingSlider.value) / 100;
                smoothingValue.textContent = `${spectrumSmoothingSlider.value}%`;
            });
            
            overSubtractionSlider.addEventListener('input', () => {
                overSubtractionFactor = parseFloat(overSubtractionSlider.value) / 100;
                overSubValue.textContent = `${overSubtractionSlider.value}%`;
            });

            inputSelect.onchange = () => {
                currentInputDeviceId = inputSelect.value || 'default';
                localStorage.setItem('audioInputDeviceId', currentInputDeviceId);
            };

            outputSelect.onchange = () => {
                if (outputSelect.disabled) return;
                currentOutputDeviceId = outputSelect.value || 'default';
                localStorage.setItem('audioOutputDeviceId', currentOutputDeviceId);
            };

            startBtn.addEventListener('click', startAudio);
            stopBtn.addEventListener('click', stopAllAudio);
            
            filterBtn.addEventListener('click', async () => {
                isFiltering = !isFiltering;
                filterBtn.classList.toggle('active', isFiltering);
                filterBtn.textContent = isFiltering ? "å…³é—­é™å™ª" : "å¯ç”¨é™å™ª";
                if (audioContext) {
                    await buildAudioGraph(isFiltering);
                }
            });
            
            recordBtn.addEventListener('click', async () => {
                if (isRecording) {
                    await stopRecording(true);
                } else {
                    await startRecording();
                }
            });
            
            calibrateBtn.addEventListener('click', calibrateNoise);
            
            // iOSé€‚é…ï¼šå™ªå£°å½•åˆ¶æŒ‰é’®
            recordNoiseBtn.addEventListener('click', startRecordingNoise);

            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                tempStream.getTracks().forEach(track => track.stop());
                await enumerateDevices();
            } catch (err) {
                log("âš ï¸ éœ€è¦éº¦å…‹é£æƒé™æ‰èƒ½æšä¸¾è®¾å¤‡");
                enumerateDevices();
            }

            navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);
        });
    </script>
</body>
</html>
