<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>å½•éŸ³æœº</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #1a1a1a;
      color: #eee;
      padding: 20px;
      margin: 0;
    }
    h2 { text-align: center; margin-bottom: 20px; }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center;
      align-items: center;
    }
    button, select, input[type="number"] {
      padding: 10px 12px;
      border: none;
      border-radius: 6px;
      background: #444;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    select, input[type="number"] {
      background: #333;
      min-width: 180px;
    }
    input[type="number"] {
      width: auto;
      min-width: 60px;
      text-align: center;
    }
    button:hover { background: #555; }
    button:disabled { background: #333; color: #777; cursor: not-allowed; }
    button.active { background: #1e88e5; }
    button.danger { background: #d32f2f; }

    .canvas-container {
      width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      border-radius: 8px;
      margin-top: 10px;
    }
    canvas {
      height: 280px;
      background: #000;
      display: block;
      cursor: pointer;
      width: 3000px;
      min-width: 3000px;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    input[type="range"] {
      width: 120px;
    }
    #log {
      color: #ffcc00;
      font-size: 12px;
      margin-top: 10px;
      min-height: 20px;
    }
    .device-selectors {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 15px 0;
    }
  </style>
</head>
<body>
  <h2>ğŸ¤ å½•éŸ³æœº</h2>

  <div class="device-selectors">
    <select id="inputSelect" disabled>
      <option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>
    </select>
    <select id="outputSelect" disabled>
      <option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>
    </select>
  </div>

  <div class="controls">
    <button id="startBtn">å¼€å§‹éŸ³é¢‘</button>
    <button id="stopBtn" disabled class="danger">å…³é—­éŸ³é¢‘</button>
    <button id="filterBtn" disabled>å¯ç”¨é™å™ª</button>
    <button id="recordBtn" disabled>å¼€å§‹å½•éŸ³</button>
    
    <div class="slider-container">
      <label>äººå£°å¢ç›Š:</label>
      <input type="range" id="gainSlider" min="0" max="200" value="100" />
      <span id="gainValue">1.0x</span>
    </div>

    <div class="slider-container">
      <label title="0 = è‡ªåŠ¨å†…å­˜ä¿æŠ¤ï¼ˆæ¨èï¼‰">æœ€å¤§æ—¶é•¿(ç§’):</label>
      <input type="number" id="maxDurationInput" min="0" max="7200" value="0" style="width:60px; background:#333; color:white; text-align:center;" />
    </div>
  </div>

  <div class="canvas-container">
    <canvas id="fftCanvas"></canvas>
  </div>
  <div id="log"></div>

  <script>
    // ================= å…¨å±€çŠ¶æ€ =================
    let audioContext = null;
    let sourceNode = null;
    let stream = null;
    let analyser = null;
    let masterGainNode = null; // ä¸»å¢ç›Šï¼ˆä¿è¯è¾“å‡ºç¨³å®šï¼‰
    let compressorNode = null; // å‹ç¼©å™¨ï¼ˆæŠ‘åˆ¶å°–å³°ï¼‰
    let filterChain = [];       // æ»¤æ³¢é“¾
    let isFiltering = false;
    let isRecording = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let currentInputDeviceId = localStorage.getItem('audioInputDeviceId') || 'default';
    let currentOutputDeviceId = localStorage.getItem('audioOutputDeviceId') || 'default';
    let fftAnimationId = null;  // FFTåŠ¨ç”»IDï¼ˆç”¨äºåœæ­¢ï¼‰

    let fileHandle = null;
    let writableStream = null;
    let writer = null;

    let recordingStartTime = null;
    let memoryGuardTimer = null;

    // ========== é™å™ªæ ¸å¿ƒé…ç½®ï¼ˆç²¾å‡†çª„å¸¦ç‰ˆï¼‰==========
    const POWER_FREQ = 50; // å·¥é¢‘é¢‘ç‡
    // ç²¾å‡†çª„å¸¦é™·æ³¢ï¼šè¦†ç›–æ ¸å¿ƒå°–å³°é¢‘ç‡ï¼ˆå«å°æ•°ä½æå‡ç²¾åº¦ï¼‰
    const notchFreqs = [
      POWER_FREQ,        // 50Hz åŸºæ³¢
      POWER_FREQ*2,      // 100Hz 2æ¬¡è°æ³¢
      POWER_FREQ*3,      // 150Hz 3æ¬¡è°æ³¢
      19.9, 60.1, 180.2  // å¸¸è§çª„å¸¦å°–å³°è¡¥å……ï¼ˆæ ¹æ®FFTæ³¢å½¢å¯è°ƒæ•´ï¼‰
    ];
    const Q_NARROW = 80;  // çª„å¸¦å°–å³°é«˜Qå€¼ï¼ˆç²¾å‡†å‹åˆ¶ï¼‰
    const Q_WIDE = 15;    // å®½é¢‘è°æ³¢ä½Qå€¼ï¼ˆé¿å…å¤±çœŸï¼‰
    const HPF_FREQ = 60;  // é«˜é€šï¼ˆè¿‡æ»¤50Hzä»¥ä¸‹åº•å™ªï¼Œå…ˆæ»¤æ³¢å†é™·æ³¢ï¼‰
    const LPF_FREQ = 15000;// ä½é€šï¼ˆè¿‡æ»¤é«˜é¢‘æ²™æ²™å°–å³°ï¼‰

    const MAX_ESTIMATED_MEMORY_BYTES = 80 * 1024 * 1024;

    // ================= DOM =================
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const filterBtn = document.getElementById('filterBtn');
    const recordBtn = document.getElementById('recordBtn');
    const gainSlider = document.getElementById('gainSlider');
    const gainValue = document.getElementById('gainValue');
    const canvas = document.getElementById('fftCanvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const inputSelect = document.getElementById('inputSelect');
    const outputSelect = document.getElementById('outputSelect');

    function log(msg) {
      console.log(msg);
      logEl.textContent = msg;
    }

    // === Canvas é…ç½® ===
    const MARGIN_LEFT = 60;
    const MARGIN_BOTTOM = 50;
    const MARGIN_RIGHT = 20;
    const MARGIN_TOP = 10;
    const LOGICAL_CANVAS_WIDTH = 3000;
    const CANVAS_HEIGHT = 280;

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = LOGICAL_CANVAS_WIDTH * dpr;
      canvas.height = CANVAS_HEIGHT * dpr;
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ================= è®¾å¤‡æšä¸¾ =================
    async function enumerateDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(d => d.kind === 'audioinput');
        const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

        inputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>';
        outputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>';

        audioInputs.forEach(device => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.text = device.label || `éº¦å…‹é£ ${inputSelect.children.length}`;
          if (device.deviceId === currentInputDeviceId) option.selected = true;
          inputSelect.appendChild(option);
        });

        if (typeof HTMLAudioElement.prototype.setSinkId === 'function') {
          audioOutputs.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `æ‰¬å£°å™¨ ${outputSelect.children.length}`;
            if (device.deviceId === currentOutputDeviceId) option.selected = true;
            outputSelect.appendChild(option);
          });
          outputSelect.disabled = false;
        } else {
          outputSelect.disabled = true;
          outputSelect.innerHTML = '<option>å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‰¬å£°å™¨é€‰æ‹©</option>';
        }

        inputSelect.disabled = false;
      } catch (err) {
        log("âŒ è®¾å¤‡æšä¸¾å¤±è´¥: " + err.message);
      }
    }

    // ========== ç²¾å‡†çª„å¸¦æ»¤æ³¢é“¾ï¼ˆè§£å†³æ²™æ²™å°–å³°ï¼‰==========
    function createPrecisionNoiseFilter() {
      // æ¸…ç©ºæ—§æ»¤æ³¢é“¾ï¼ˆå¸¦å®¹é”™ï¼‰
      filterChain.forEach(node => {
        try { 
          node.disconnect(); 
          if (node instanceof AudioNode) node = null;
        } catch (e) {}
      });
      filterChain = [];

      // 1. å‰ç½®é«˜é€šï¼šå…ˆè¿‡æ»¤ä½é¢‘åº•å™ªï¼Œé¿å…æ”¾å¤§å°–å³°
      const highpass = audioContext.createBiquadFilter();
      highpass.type = 'highpass';
      highpass.frequency.value = HPF_FREQ;
      highpass.Q.value = 0.707; // å·´ç‰¹æ²ƒæ–¯ç‰¹æ€§ï¼Œè¿‡æ¸¡å¹³æ»‘
      highpass.frequency.setValueAtTime(HPF_FREQ, audioContext.currentTime);
      filterChain.push(highpass);

      // 2. ç²¾å‡†çª„å¸¦é™·æ³¢ï¼šåŒºåˆ†å°–å³°/è°æ³¢è®¾ç½®ä¸åŒQå€¼
      notchFreqs.forEach((freq, index) => {
        const notch = audioContext.createBiquadFilter();
        notch.type = 'notch';
        notch.frequency.value = freq;
        // å‰3ä¸ªæ˜¯å·¥é¢‘è°æ³¢ï¼ˆå®½é¢‘ï¼‰ï¼Œå3ä¸ªæ˜¯çª„å¸¦å°–å³°ï¼ˆé«˜Qï¼‰
        notch.Q.value = index < 3 ? Q_WIDE : Q_NARROW;
        // å¹³æ»‘è®¾ç½®é¢‘ç‡ï¼Œé¿å…çªå˜
        notch.frequency.setValueAtTime(freq, audioContext.currentTime);
        filterChain[filterChain.length-1].connect(notch);
        filterChain.push(notch);
      });

      // 3. åç½®ä½é€šï¼šè¿‡æ»¤é«˜é¢‘æ²™æ²™å°–å³°
      const lowpass = audioContext.createBiquadFilter();
      lowpass.type = 'lowpass';
      lowpass.frequency.value = LPF_FREQ;
      lowpass.Q.value = 0.707;
      filterChain[filterChain.length-1].connect(lowpass);
      filterChain.push(lowpass);

      // 4. äººå£°å¢ç›Šï¼ˆå¹³æ»‘è°ƒæ•´ï¼‰
      const gain = audioContext.createGain();
      gain.gain.value = parseFloat(gainSlider.value) / 100;
      gain.gain.setValueAtTime(gain.gain.value, audioContext.currentTime);
      filterChain[filterChain.length-1].connect(gain);
      filterChain.push(gain);

      // 5. å‹ç¼©å™¨ï¼šæŠ‘åˆ¶å°–å³°éŸ³é‡ï¼Œå‡å°‘æ²™æ²™å£°æ„ŸçŸ¥
      if (!compressorNode) {
        compressorNode = audioContext.createDynamicsCompressor();
        compressorNode.threshold.value = -24; // é˜ˆå€¼
        compressorNode.knee.value = 12;       // æ‹ç‚¹ï¼ˆå¹³æ»‘è¿‡æ¸¡ï¼‰
        compressorNode.ratio.value = 4;       // å‹ç¼©æ¯”
        compressorNode.attack.value = 0.005;  // å¿«é€Ÿå“åº”å°–å³°
        compressorNode.release.value = 0.2;   // ç¼“æ…¢é‡Šæ”¾ï¼Œé¿å…æ–­éŸ³
      }
      filterChain[filterChain.length-1].connect(compressorNode);
      filterChain.push(compressorNode);

      return {
        input: filterChain[0],
        output: filterChain[filterChain.length-1]
      };
    }

    // ========== ç¨³å®šéŸ³é¢‘å›¾æ„å»ºï¼ˆè§£å†³æ–­ç»­ï¼‰==========
    function buildAudioGraph(enableFilter) {
      // åœæ­¢æ—§çš„FFTç»˜åˆ¶ï¼Œé¿å…èµ„æºå ç”¨
      if (fftAnimationId) {
        cancelAnimationFrame(fftAnimationId);
        fftAnimationId = null;
      }

      // é‡ç½®åˆ†æå™¨ï¼ˆå¸¦å®¹é”™ï¼‰
      if (analyser) {
        try { analyser.disconnect(); } catch (e) {}
        analyser = null;
      }
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.8; // å¹³æ»‘FFTæ³¢å½¢ï¼Œå‡å°‘æŠ–åŠ¨

      // ç¡®ä¿ä¸»å¢ç›ŠèŠ‚ç‚¹å­˜åœ¨ä¸”ç¨³å®š
      if (!masterGainNode) {
        masterGainNode = audioContext.createGain();
        masterGainNode.gain.value = 0; // åˆå§‹é™éŸ³ï¼Œé¿å…å¯åŠ¨çˆ†éŸ³
        // å¹³æ»‘æå‡éŸ³é‡ï¼Œè§£å†³å¯åŠ¨æ–­éŸ³
        masterGainNode.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + 0.1);
        masterGainNode.connect(audioContext.destination);
      }

      // æ–­å¼€sourceNodeæ—§è¿æ¥ï¼ˆå¸¦å®¹é”™ï¼‰
      try { sourceNode.disconnect(); } catch (e) {}

      if (enableFilter) {
        // å¯ç”¨é™å™ªï¼šsource â†’ ç²¾å‡†æ»¤æ³¢é“¾ â†’ åˆ†æå™¨ â†’ ä¸»å¢ç›Š â†’ æ‰¬å£°å™¨
        const filter = createPrecisionNoiseFilter();
        sourceNode.connect(filter.input);
        filter.output.connect(analyser);
        analyser.connect(masterGainNode);
        log("âœ… é™å™ªå·²å¯ç”¨ï¼ˆç²¾å‡†çª„å¸¦æ»¤æ³¢+å‹ç¼©ï¼‰");
      } else {
        // ç¦ç”¨é™å™ªï¼šsource â†’ åˆ†æå™¨ â†’ ä¸»å¢ç›Š â†’ æ‰¬å£°å™¨ï¼ˆå‹ç¼©å™¨ä»ä¿ç•™ï¼‰
        sourceNode.connect(analyser);
        analyser.connect(masterGainNode);
        // å‹ç¼©å™¨ä»å·¥ä½œï¼ŒæŠ‘åˆ¶å°–å³°
        if (compressorNode) {
          analyser.connect(compressorNode);
          compressorNode.connect(masterGainNode);
        }
        log("âœ… é™å™ªå·²å…³é—­ï¼ˆä¿ç•™å‹ç¼©å™¨æŠ‘åˆ¶å°–å³°ï¼‰");
      }

      // é‡å¯FFTç»˜åˆ¶ï¼ˆé™ä½å¸§ç‡ï¼Œå‡å°‘èµ„æºå ç”¨ï¼‰
      drawFFT();
    }

    // ================= è¾…åŠ©å‡½æ•° =================
    function estimateRecordedSize() {
      if (!recordedChunks.length) return 0;
      return recordedChunks.reduce((total, chunk) => total + chunk.size, 0);
    }

    function checkMemoryPressure() {
      if (!isRecording || !recordingStartTime) return;

      const maxDurationInput = document.getElementById('maxDurationInput');
      const maxDurationSeconds = parseInt(maxDurationInput?.value) || 0;

      if (maxDurationSeconds > 0) {
        const elapsedSeconds = (Date.now() - recordingStartTime) / 1000;
        if (elapsedSeconds >= maxDurationSeconds) {
          console.log(`[Auto Stop] Reached max duration: ${maxDurationSeconds}s`);
          stopRecording(true);
          return;
        }
      }

      if (maxDurationSeconds === 0 && !fileHandle) {
        const estimated = estimateRecordedSize();
        if (estimated > MAX_ESTIMATED_MEMORY_BYTES * 0.9) {
          console.warn(`[Auto Stop] Memory limit reached: ${(estimated / 1024 / 1024).toFixed(1)}MB`);
          stopRecording(true);
        }
      }
    }

    function clearGuardTimer() {
      if (memoryGuardTimer) {
        clearInterval(memoryGuardTimer);
        memoryGuardTimer = null;
      }
    }

    function generateFilename() {
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
      return `recording_${timestamp}.m4a`;
    }

    // ================= éŸ³é¢‘æ§åˆ¶ï¼ˆç¨³å®šç‰ˆï¼‰=================
    async function stopAllAudio() {
      clearGuardTimer();

      // åœæ­¢FFTç»˜åˆ¶ï¼Œé‡Šæ”¾èµ„æº
      if (fftAnimationId) {
        cancelAnimationFrame(fftAnimationId);
        fftAnimationId = null;
      }

      if (isRecording) {
        await stopRecording(false);
      }

      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }

      if (audioContext) {
        try { 
          // å…ˆé™éŸ³ä¸»å¢ç›Šï¼Œå†å…³é—­ï¼Œé¿å…çˆ†éŸ³
          if (masterGainNode) masterGainNode.gain.value = 0;
          await audioContext.close(); 
        } catch (e) {}
        audioContext = null;
      }

      // é‡ç½®æ‰€æœ‰èŠ‚ç‚¹ï¼ˆå½»åº•é‡Šæ”¾ï¼‰
      sourceNode = null;
      analyser = null;
      masterGainNode = null;
      compressorNode = null;
      filterChain.forEach(node => { try { node.disconnect(); } catch (e) {} });
      filterChain = [];
      isFiltering = false;

      // é‡ç½®UI
      startBtn.disabled = false;
      startBtn.textContent = "å¼€å§‹éŸ³é¢‘";
      stopBtn.disabled = true;
      filterBtn.disabled = true;
      filterBtn.classList.remove('active');
      filterBtn.textContent = "å¯ç”¨é™å™ª";
      recordBtn.disabled = true;
      recordBtn.classList.remove('active');
      recordBtn.textContent = "å¼€å§‹å½•éŸ³";
      inputSelect.disabled = false;
      log("éŸ³é¢‘å·²å…³é—­");
    }

    async function stopRecording(save = true) {
      if (!isRecording) return;

      isRecording = false;
      recordingStartTime = null;
      clearGuardTimer();

      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      let filename = generateFilename();
      let mimeType = 'audio/mp4';

      if (!MediaRecorder.isTypeSupported('audio/mp4')) {
        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          mimeType = 'audio/webm;codecs=opus';
          filename = filename.replace('.m4a', '.webm');
        } else {
          mimeType = 'audio/webm';
          filename = filename.replace('.m4a', '.webm');
        }
      }

      if (writer) {
        try {
          await writer.close();
          if (save) log(`âœ… å½•éŸ³å·²ä¿å­˜ä¸º: ${filename}`);
        } catch (e) {
          console.warn('Writer close error:', e);
          if (save) log('âš ï¸ æ–‡ä»¶å†™å…¥æœªå®Œæˆ');
        }
        writer = null;
        writableStream = null;
        fileHandle = null;
      }

      if (save && recordedChunks.length > 0 && !fileHandle) {
        const blob = new Blob(recordedChunks, { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        log(`âœ… å½•éŸ³å·²ä¿å­˜ä¸º: ${filename}`);
      }

      recordedChunks = [];
      mediaRecorder = null;
      recordBtn.textContent = "å¼€å§‹å½•éŸ³";
      recordBtn.classList.remove('active');
    }

    // ================= äº‹ä»¶ç»‘å®šï¼ˆç¨³å®šç‰ˆï¼‰=================
    startBtn.onclick = async () => {
      try {
        log("æ­£åœ¨å¯åŠ¨éŸ³é¢‘...");

        // 1. å…ˆåˆ›å»ºAudioContextï¼ˆç”¨æˆ·äº¤äº’æ—¶åˆ›å»ºï¼Œé¿å…æ‚¬æµ®ï¼‰
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)({
            latencyHint: 'interactive', // ä½å»¶è¿Ÿæ¨¡å¼ï¼Œå‡å°‘æ–­ç»­
            sampleRate: 44100
          });
        }
        // 2. æ¢å¤AudioContextï¼ˆé¿å…suspendedçŠ¶æ€ï¼‰
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        // 3. è·å–éº¦å…‹é£æµï¼ˆå¸¦çº¦æŸï¼Œä¿è¯å•å£°é“/ä½å»¶è¿Ÿï¼‰
        const constraints = {
          audio: {
            deviceId: currentInputDeviceId === 'default' ? undefined : { exact: currentInputDeviceId },
            sampleRate: 44100,
            channelCount: 1,
            echoCancellation: true, // å¼€å¯å›å£°æ¶ˆé™¤
            noiseSuppression: false // å…³é—­æµè§ˆå™¨é»˜è®¤é™å™ªï¼Œç”¨è‡ªå®šä¹‰æ»¤æ³¢
          }
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        sourceNode = audioContext.createMediaStreamSource(stream);

        // 4. åˆå§‹åŒ–ä¸»å¢ç›Šå’Œå‹ç¼©å™¨ï¼ˆæå‰åˆ›å»ºï¼Œé¿å…åŠ¨æ€ä¸­æ–­ï¼‰
        if (!masterGainNode) {
          masterGainNode = audioContext.createGain();
          masterGainNode.gain.value = 0; // åˆå§‹é™éŸ³
          masterGainNode.connect(audioContext.destination);
        }
        if (!compressorNode) {
          compressorNode = audioContext.createDynamicsCompressor();
          compressorNode.threshold.value = -24;
          compressorNode.knee.value = 12;
          compressorNode.ratio.value = 4;
          compressorNode.attack.value = 0.005;
          compressorNode.release.value = 0.2;
        }

        // 5. æ„å»ºéŸ³é¢‘å›¾ï¼ˆç¦ç”¨é™å™ªï¼Œé¿å…å¯åŠ¨æ—¶æ»¤æ³¢å¤æ‚ï¼‰
        buildAudioGraph(false);

        // 6. å¹³æ»‘æå‡ä¸»å¢ç›Šï¼Œè§£å†³å¯åŠ¨çˆ†éŸ³/æ–­éŸ³
        masterGainNode.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + 0.2);

        // æ›´æ–°UI
        startBtn.disabled = true;
        startBtn.textContent = "âœ… éŸ³é¢‘è¿è¡Œä¸­";
        stopBtn.disabled = false;
        filterBtn.disabled = false;
        recordBtn.disabled = false;
        inputSelect.disabled = true;
        log("éŸ³é¢‘å·²å¯åŠ¨ï¼ï¼ˆä½å»¶è¿Ÿæ¨¡å¼ï¼‰");

      } catch (err) {
        log("âŒ éº¦å…‹é£é”™è¯¯: " + err.message);
        alert("æ— æ³•è®¿é—®éº¦å…‹é£: " + err.message);
        // å‡ºé”™æ—¶æ¸…ç†èµ„æº
        if (audioContext) await audioContext.close();
        audioContext = null;
        stream = null;
        sourceNode = null;
      }
    };

    stopBtn.onclick = () => {
      stopAllAudio();
    };

    inputSelect.onchange = () => {
      currentInputDeviceId = inputSelect.value || 'default';
      localStorage.setItem('audioInputDeviceId', currentInputDeviceId);
    };

    outputSelect.onchange = () => {
      if (outputSelect.disabled) return;
      currentOutputDeviceId = outputSelect.value || 'default';
      localStorage.setItem('audioOutputDeviceId', currentOutputDeviceId);
    };

    filterBtn.onclick = () => {
      isFiltering = !isFiltering;
      filterBtn.classList.toggle('active', isFiltering);
      filterBtn.textContent = isFiltering ? "å…³é—­é™å™ª" : "å¯ç”¨é™å™ª";
      if (audioContext) {
        // åˆ‡æ¢æ»¤æ³¢æ—¶å…ˆé™ä½éŸ³é‡ï¼Œé¿å…çªå˜
        masterGainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.1);
        buildAudioGraph(isFiltering);
        // æ¢å¤éŸ³é‡
        masterGainNode.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + 0.2);
      }
    };

    gainSlider.oninput = () => {
      const g = gainSlider.value / 100;
      gainValue.textContent = g.toFixed(1) + 'x';
      // å¹³æ»‘æ›´æ–°å¢ç›Šï¼Œé¿å…çªå˜
      if (audioContext) {
        if (isFiltering && filterChain.length > 0) {
          filterChain[filterChain.length - 2].gain.linearRampToValueAtTime(
            g, audioContext.currentTime + 0.1
          );
        } else if (masterGainNode) {
          masterGainNode.gain.linearRampToValueAtTime(
            g, audioContext.currentTime + 0.1
          );
        }
      }
    };

    recordBtn.onclick = async () => {
      if (isRecording) {
        await stopRecording(true);
        return;
      }

      try {
        let useStreamWrite = false;
        let mimeType = 'audio/mp4';

        if ('showSaveFilePicker' in window) {
          try {
            const filename = generateFilename();
            fileHandle = await window.showSaveFilePicker({
              suggestedName: filename,
              types: [{
                description: 'éŸ³é¢‘æ–‡ä»¶',
                accept: {
                  'audio/mp4': ['.m4a'],
                  'audio/webm': ['.webm']
                }
              }]
            });
            useStreamWrite = true;
          } catch (err) {
            if (err.name !== 'AbortError') console.warn('File picker error:', err);
            fileHandle = null;
          }
        }

        if (!useStreamWrite) {
          if (!MediaRecorder.isTypeSupported('audio/mp4')) {
            mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
              ? 'audio/webm;codecs=opus' 
              : 'audio/webm';
          }
          recordedChunks = [];
        }

        // å½•éŸ³æºï¼šä½¿ç”¨å¤„ç†åçš„éŸ³é¢‘ï¼ˆä¿è¯å’Œç›‘å¬ä¸€è‡´ï¼‰
        const dest = audioContext.createMediaStreamDestination();
        if (isFiltering && filterChain.length > 0) {
          filterChain[filterChain.length-1].connect(dest);
        } else {
          analyser.connect(dest);
        }

        // ç¡®ä¿å½•éŸ³æ—¶ç›‘å¬ä¸ä¸­æ–­ï¼ˆä¸»å¢ç›Šå§‹ç»ˆè¿æ¥è¾“å‡ºï¼‰
        masterGainNode.connect(audioContext.destination);

        mediaRecorder = new MediaRecorder(dest.stream, { 
          mimeType,
          audioBitsPerSecond: 128000 // å›ºå®šç ç‡ï¼Œå‡å°‘å½•éŸ³æ–­ç»­
        });

        // å¤„ç†å½•éŸ³æ•°æ®
        if (useStreamWrite) {
          writableStream = await fileHandle.createWritable();
          writer = writableStream.getWriter();
          mediaRecorder.ondataavailable = async (e) => {
            if (e.data.size > 0 && writer) {
              try { await writer.write(await e.data.arrayBuffer()); } 
              catch (e) { log('âš ï¸ å†™å…¥æ–‡ä»¶å¤±è´¥'); }
            }
          };
        } else {
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) recordedChunks.push(e.data);
          };
        }

        mediaRecorder.onerror = (e) => {
          log("âš ï¸ å½•éŸ³é”™è¯¯: " + e.error);
          stopRecording(false);
        };

        // å¼€å§‹å½•éŸ³ï¼ˆå»¶è¿Ÿå¯åŠ¨ï¼Œé¿å…èŠ‚ç‚¹è¿æ¥æœªå®Œæˆï¼‰
        setTimeout(() => {
          mediaRecorder.start(100);
          recordingStartTime = Date.now();
          memoryGuardTimer = setInterval(checkMemoryPressure, 500);

          isRecording = true;
          recordBtn.textContent = "åœæ­¢å½•éŸ³";
          recordBtn.classList.add('active');

          const mode = useStreamWrite ? 'ï¼ˆæµå¼å†™å…¥ï¼‰' : 'ï¼ˆå†…å­˜ç¼“å­˜ Â· è‡ªåŠ¨ä¿æŠ¤ï¼‰';
          log("ğŸ™ï¸ å½•éŸ³å·²å¼€å§‹" + mode);
        }, 100);

      } catch (err) {
        log("âŒ å½•éŸ³å¯åŠ¨å¤±è´¥: " + err.message);
        console.error(err);
      }
    };

    // ======== ä¼˜åŒ–FFTç»˜åˆ¶ï¼ˆé™ä½èµ„æºå ç”¨ï¼‰========
    function drawFFT() {
      if (!analyser) return;
      // é™ä½ç»˜åˆ¶é¢‘ç‡ï¼ˆæ¯2å¸§ç»˜åˆ¶ä¸€æ¬¡ï¼‰ï¼Œå‡å°‘ä¸»çº¿ç¨‹å ç”¨
      fftAnimationId = requestAnimationFrame(() => {
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyser.getByteFrequencyData(dataArray);

        // æ¸…ç©ºç”»å¸ƒ
        ctx.clearRect(0, 0, LOGICAL_CANVAS_WIDTH, CANVAS_HEIGHT);
        const plotWidth = LOGICAL_CANVAS_WIDTH - MARGIN_LEFT - MARGIN_RIGHT;
        const plotHeight = CANVAS_HEIGHT - MARGIN_TOP - MARGIN_BOTTOM;

        // ç»˜åˆ¶é¢‘è°±ï¼ˆç®€åŒ–è®¡ç®—ï¼Œå‡å°‘å¾ªç¯è€—æ—¶ï¼‰
        const barWidth = plotWidth / bufferLength;
        ctx.fillStyle = 'cyan';
        for (let i = 0; i < bufferLength; i++) {
          const barHeight = (dataArray[i] / 255) * plotHeight;
          const x = MARGIN_LEFT + i * barWidth;
          const y = MARGIN_TOP + (plotHeight - barHeight);
          ctx.fillRect(x, y, barWidth - 1, barHeight);
        }

        // ç»˜åˆ¶åæ ‡è½´ï¼ˆç®€åŒ–ï¼Œå‡å°‘ç»˜åˆ¶æ¬¡æ•°ï¼‰
        ctx.fillStyle = '#aaa';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const sampleRate = audioContext.sampleRate || 44100;
        const nyquist = sampleRate / 2;
        const xLabels = [];
        for (let f = 0; f <= 22000; f += 4000) { // å‡å°‘æ ‡ç­¾æ•°é‡
          xLabels.push({ freq: f, ratio: f / nyquist });
        }
        if (nyquist > 22000) xLabels.push({ freq: Math.round(nyquist), ratio: 1 });
        xLabels.forEach(label => {
          const x = MARGIN_LEFT + label.ratio * plotWidth;
          if (x >= MARGIN_LEFT && x <= LOGICAL_CANVAS_WIDTH - MARGIN_RIGHT) {
            ctx.fillText(`${Math.round(label.freq / 1000)}k`, x, CANVAS_HEIGHT - MARGIN_BOTTOM + 10);
            ctx.beginPath();
            ctx.moveTo(x, CANVAS_HEIGHT - MARGIN_BOTTOM);
            ctx.lineTo(x, CANVAS_HEIGHT - MARGIN_BOTTOM + 5);
            ctx.strokeStyle = '#555';
            ctx.stroke();
          }
        });
        ctx.fillText('é¢‘ç‡ (Hz)', LOGICAL_CANVAS_WIDTH / 2, CANVAS_HEIGHT - 10);

        // Yè½´æ ‡ç­¾ï¼ˆç®€åŒ–ï¼‰
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        const yLabels = [{ value: 255, ratio: 0 }, { value: 128, ratio: 0.5 }, { value: 0, ratio: 1 }];
        yLabels.forEach(label => {
          const y = MARGIN_TOP + label.ratio * plotHeight;
          ctx.fillText(label.value.toString(), MARGIN_LEFT - 10, y);
          ctx.beginPath();
          ctx.moveTo(MARGIN_LEFT - 5, y);
          ctx.lineTo(MARGIN_LEFT + 5, y);
          ctx.strokeStyle = '#555';
          ctx.stroke();
        });

        ctx.save();
        ctx.translate(15, CANVAS_HEIGHT / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('å¹…åº¦', 0, 0);
        ctx.restore();

        drawFFT();
      });
    }

    // ======== ç‚¹å‡»è·å–é¢‘ç‡ï¼ˆè¾…åŠ©è°ƒæ•´æ»¤æ³¢å‚æ•°ï¼‰========
    function handleCanvasClick(clientX, clientY) {
      if (!analyser || !audioContext) return;

      const containerRect = document.querySelector('.canvas-container').getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const scrollLeft = document.querySelector('.canvas-container').scrollLeft;

      const x = clientX - canvasRect.left + scrollLeft;
      const plotWidth = LOGICAL_CANVAS_WIDTH - MARGIN_LEFT - MARGIN_RIGHT;
      if (x < MARGIN_LEFT || x > LOGICAL_CANVAS_WIDTH - MARGIN_RIGHT) return;

      const normalizedX = (x - MARGIN_LEFT) / plotWidth;
      const freq = normalizedX * (audioContext.sampleRate / 2);
      log(`ğŸ–±ï¸ å½“å‰é¢‘ç‡: ${freq.toFixed(1)} Hzï¼ˆå¯æ·»åŠ åˆ°é™·æ³¢åˆ—è¡¨ï¼‰`);
    }

    canvas.addEventListener('click', (e) => handleCanvasClick(e.clientX, e.clientY));
    canvas.addEventListener('touchend', (e) => {
      if (e.changedTouches.length > 0) {
        handleCanvasClick(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        e.preventDefault();
      }
    }, { passive: false });

    // åˆå§‹åŒ–
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(stream => {
        stream.getTracks().forEach(track => track.stop());
        enumerateDevices();
      })
      .catch(() => enumerateDevices());
    navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);
  </script>
</body>
</html>
