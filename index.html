<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>å½•éŸ³æœº</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #1a1a1a;
      color: #eee;
      padding: 20px;
      margin: 0;
    }
    h2 { text-align: center; margin-bottom: 20px; }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center;
      align-items: center;
    }
    button, select, input[type="number"] {
      padding: 10px 12px;
      border: none;
      border-radius: 6px;
      background: #444;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    select, input[type="number"] {
      background: #333;
      min-width: 180px;
    }
    input[type="number"] {
      width: auto;
      min-width: 60px;
      text-align: center;
    }
    button:hover { background: #555; }
    button:disabled { background: #333; color: #777; cursor: not-allowed; }
    button.active { background: #1e88e5; }
    button.danger { background: #d32f2f; }

    /* æ–°å¢ï¼šåŒ…è£¹ canvas çš„å¯æ»šåŠ¨å®¹å™¨ */
    .canvas-container {
      width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      border-radius: 8px;
      margin-top: 10px;
    }
    canvas {
      height: 280px;
      background: #000;
      display: block;
      cursor: pointer;
      /* é€»è¾‘å®½åº¦æ‹‰é•¿ä»¥æ”¯æŒå…¨é¢‘æ®µç»†èŠ‚ */
      width: 3000px;
      min-width: 3000px;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    input[type="range"] {
      width: 120px;
    }
    #log {
      color: #ffcc00;
      font-size: 12px;
      margin-top: 10px;
      min-height: 20px;
    }
    .device-selectors {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 15px 0;
    }
  </style>
</head>
<body>
  <h2>ğŸ¤ å½•éŸ³æœº</h2>

  <div class="device-selectors">
    <select id="inputSelect" disabled>
      <option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>
    </select>
    <select id="outputSelect" disabled>
      <option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>
    </select>
  </div>

  <div class="controls">
    <button id="startBtn">å¼€å§‹éŸ³é¢‘</button>
    <button id="stopBtn" disabled class="danger">å…³é—­éŸ³é¢‘</button>
    <button id="filterBtn" disabled>å¯ç”¨æ»¤æ³¢</button>
    <button id="recordBtn" disabled>å¼€å§‹å½•éŸ³</button>
    
    <div class="slider-container">
      <label>äººå£°å¢ç›Š:</label>
      <input type="range" id="gainSlider" min="0" max="300" value="150" />
      <span id="gainValue">1.5x</span>
    </div>

    <div class="slider-container">
      <label title="0 = è‡ªåŠ¨å†…å­˜ä¿æŠ¤ï¼ˆæ¨èï¼‰">æœ€å¤§æ—¶é•¿(ç§’):</label>
      <input type="number" id="maxDurationInput" min="0" max="7200" value="0" style="width:60px; background:#333; color:white; text-align:center;" />
    </div>
  </div>

  <!-- æ–°å¢å®¹å™¨ -->
  <div class="canvas-container">
    <canvas id="fftCanvas"></canvas>
  </div>
  <div id="log"></div>

  <script>
    // ================= å…¨å±€çŠ¶æ€ =================
    let audioContext = null;
    let sourceNode = null;
    let stream = null;
    let analyser = null;
    let gainNode = null;
    let filters = [];
    let isFiltering = false;
    let isRecording = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let currentInputDeviceId = localStorage.getItem('audioInputDeviceId') || 'default';
    let currentOutputDeviceId = localStorage.getItem('audioOutputDeviceId') || 'default';

    let fileHandle = null;
    let writableStream = null;
    let writer = null;

    let recordingStartTime = null;
    let memoryGuardTimer = null;

    const notchFreqs = [50, 95, 100, 150, 200, 250, 285, 350, 450, 550, 650, 850, 950];
    const Q = 35;
    const MAX_ESTIMATED_MEMORY_BYTES = 80 * 1024 * 1024;

    // ================= DOM =================
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const filterBtn = document.getElementById('filterBtn');
    const recordBtn = document.getElementById('recordBtn');
    const gainSlider = document.getElementById('gainSlider');
    const gainValue = document.getElementById('gainValue');
    const canvas = document.getElementById('fftCanvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const inputSelect = document.getElementById('inputSelect');
    const outputSelect = document.getElementById('outputSelect');

    function log(msg) {
      console.log(msg);
      logEl.textContent = msg;
    }

    // === è¾¹è·è°ƒæ•´ï¼šåº•éƒ¨ç•™è¶³ç©ºé—´ç»™æ ‡ç­¾ ===
    const MARGIN_LEFT = 60;
    const MARGIN_BOTTOM = 50; // å¢å¤§åº•éƒ¨è¾¹è·
    const MARGIN_RIGHT = 20;
    const MARGIN_TOP = 10;

    // é€»è¾‘ç»˜å›¾å®½åº¦ï¼ˆå›ºå®šï¼Œç”¨äºå…¨é¢‘æ®µå±•å¼€ï¼‰
    const LOGICAL_CANVAS_WIDTH = 3000; // ä¸ CSS ä¸­ canvas width ä¸€è‡´
    const CANVAS_HEIGHT = 280;

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = LOGICAL_CANVAS_WIDTH * dpr;
      canvas.height = CANVAS_HEIGHT * dpr;
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ================= è®¾å¤‡æšä¸¾ =================
    async function enumerateDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(d => d.kind === 'audioinput');
        const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

        inputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©éº¦å…‹é£</option>';
        outputSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ‰¬å£°å™¨</option>';

        audioInputs.forEach(device => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.text = device.label || `éº¦å…‹é£ ${inputSelect.children.length}`;
          if (device.deviceId === currentInputDeviceId) option.selected = true;
          inputSelect.appendChild(option);
        });

        if (typeof HTMLAudioElement.prototype.setSinkId === 'function') {
          audioOutputs.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `æ‰¬å£°å™¨ ${outputSelect.children.length}`;
            if (device.deviceId === currentOutputDeviceId) option.selected = true;
            outputSelect.appendChild(option);
          });
          outputSelect.disabled = false;
        } else {
          outputSelect.disabled = true;
          outputSelect.innerHTML = '<option>å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‰¬å£°å™¨é€‰æ‹©</option>';
        }

        inputSelect.disabled = false;
      } catch (err) {
        log("âŒ è®¾å¤‡æšä¸¾å¤±è´¥: " + err.message);
      }
    }

    function buildAudioGraph(enableFilter) {
      filters.forEach(f => f.disconnect());
      filters = [];

      analyser = audioContext.createAnalyser();
      analyser.fftSize = 1024;

      let currentNode = sourceNode;

      if (enableFilter) {
        // åˆ›å»ºä¸€ä¸ªScriptProcessorNodeæ¥å®ç°æ›´å¤æ‚çš„é™å™ªå¤„ç†
        const scriptNode = audioContext.createScriptProcessor(4096, 1, 1);
        
        // å­˜å‚¨ç”¨äºé™å™ªçš„æ•°æ®
        let samplesBuffer = new Float32Array(0);
        const sampleRate = audioContext.sampleRate;
        
        // ç”¨äºé™å™ªå¤„ç†çš„å‡½æ•°
        scriptNode.onaudioprocess = function(e) {
          const inputData = e.inputBuffer.getChannelData(0);
          const outputData = e.outputBuffer.getChannelData(0);
          
          // å°†æ–°æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
          const newBuffer = new Float32Array(samplesBuffer.length + inputData.length);
          newBuffer.set(samplesBuffer);
          newBuffer.set(inputData, samplesBuffer.length);
          samplesBuffer = newBuffer;
          
          // å¦‚æœç¼“å†²åŒºè¶³å¤Ÿå¤§ï¼Œè¿›è¡Œé™å™ªå¤„ç†
          if (samplesBuffer.length >= 4096) {
            // å¤„ç†é™å™ª - æ¨¡æ‹ŸPythonä»£ç ä¸­çš„é™å™ªæµç¨‹
            let processed = removeHum(samplesBuffer.slice(0, 4096), sampleRate);
            
            // å°†å¤„ç†åçš„æ•°æ®å¤åˆ¶åˆ°è¾“å‡º
            for (let i = 0; i < outputData.length; i++) {
              outputData[i] = processed[i];
            }
            
            // ä¿ç•™æœªå¤„ç†çš„æ•°æ®
            samplesBuffer = samplesBuffer.slice(4096);
          } else {
            // å¦‚æœç¼“å†²åŒºä¸å¤Ÿå¤§ï¼Œç›´æ¥è¾“å‡ºåŸæ•°æ®
            for (let i = 0; i < outputData.length; i++) {
              outputData[i] = inputData[i];
            }
          }
        };
        
        currentNode.connect(scriptNode);
        scriptNode.connect(analyser);
        analyser.connect(audioContext.destination);
        
        // å°†scriptNodeä¹Ÿæ·»åŠ åˆ°filtersæ•°ç»„ä¸­
        filters.push(scriptNode);
      } else {
        currentNode.connect(analyser);
        analyser.connect(audioContext.destination);
      }
    }

    // æ¨¡æ‹ŸPythoné™å™ªå¤„ç†çš„å‡½æ•°
    function removeHum(data, sampleRate) {
      // 1. é™·æ³¢æ»¤æ³¢å™¨å¤„ç†ç”µæµå£°
      let processed = applyNotchFilters(data, sampleRate);
      
      // 2. æ¨¡æ‹Ÿnr.reduce_noise - ä½¿ç”¨ç®€å•çš„è°±å‡æ³•
      processed = spectralSubtraction(processed, sampleRate);
      
      // 3. é«˜é€šæ»¤æ³¢å™¨
      processed = applyHighPassFilter(processed, sampleRate, 40);
      
      return processed;
    }

    // é™·æ³¢æ»¤æ³¢å™¨
    function applyNotchFilters(data, sampleRate) {
      let result = new Float32Array(data);
      
      for (const f0 of notchFreqs) {
        result = applyIIRNotch(result, f0, Q, sampleRate);
      }
      
      return result;
    }

    // IIRé™·æ³¢æ»¤æ³¢å™¨å®ç°
    function applyIIRNotch(data, f0, Q, fs) {
      const w0 = 2 * Math.PI * f0 / fs;
      const alpha = Math.sin(w0) / (2 * Q);
      
      const b0 = 1;
      const b1 = -2 * Math.cos(w0);
      const b2 = 1;
      const a0 = 1 + alpha;
      const a1 = -2 * Math.cos(w0);
      const a2 = 1 - alpha;
      
      // å½’ä¸€åŒ–ç³»æ•°
      const norm_b0 = b0 / a0;
      const norm_b1 = b1 / a0;
      const norm_b2 = b2 / a0;
      const norm_a1 = a1 / a0;
      const norm_a2 = a2 / a0;
      
      const result = new Float32Array(data.length);
      let x1 = 0, x2 = 0, y1 = 0, y2 = 0;
      
      for (let i = 0; i < data.length; i++) {
        const x = data[i];
        const y = norm_b0 * x + norm_b1 * x1 + norm_b2 * x2 - norm_a1 * y1 - norm_a2 * y2;
        
        result[i] = y;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      
      return result;
    }

    // è°±å‡æ³•é™å™ª
    function spectralSubtraction(data, sampleRate) {
      // ç®€åŒ–çš„è°±å‡æ³•å®ç°
      const frameSize = 1024;
      const result = new Float32Array(data.length);
      
      for (let i = 0; i < data.length; i += frameSize) {
        const frame = data.slice(i, Math.min(i + frameSize, data.length));
        
        // è®¡ç®—FFT
        const fft = realFFT(frame);
        
        // ä¼°è®¡å™ªå£°è°±ï¼ˆä½¿ç”¨å‰å‡ å¸§çš„å¹³å‡å€¼ï¼‰
        if (i < 3 * frameSize) { // å‰3å¸§ä½œä¸ºå™ªå£°ä¼°è®¡
          // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„å™ªå£°ä¼°è®¡
          for (let j = 0; j < fft.length; j++) {
            fft[j] = Math.max(0, fft[j] - 0.05); // ç®€åŒ–çš„å™ªå£°ä¼°è®¡
          }
        }
        
        // è°±å‡
        for (let j = 0; j < fft.length; j++) {
          fft[j] = Math.max(0, fft[j] - 0.1); // ç®€åŒ–çš„è°±å‡
        }
        
        // é€†FFT
        const ifftResult = realIFFT(fft);
        
        // æ·»åŠ åˆ°ç»“æœä¸­
        for (let j = 0; j < ifftResult.length && i + j < result.length; j++) {
          result[i + j] = ifftResult[j];
        }
      }
      
      return result;
    }

    // ç®€åŒ–çš„å®æ•°FFTå®ç°
    function realFFT(signal) {
      // è¿™é‡Œä½¿ç”¨ç®€å•çš„DFTå®ç°ï¼Œå®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ›´é«˜æ•ˆçš„FFTç®—æ³•
      const N = signal.length;
      const result = new Float32Array(N);
      
      for (let k = 0; k < N; k++) {
        let real = 0;
        let imag = 0;
        
        for (let n = 0; n < N; n++) {
          const angle = -2 * Math.PI * k * n / N;
          real += signal[n] * Math.cos(angle);
          imag += signal[n] * Math.sin(angle);
        }
        
        result[k] = Math.sqrt(real * real + imag * imag);
      }
      
      return result;
    }

    // ç®€åŒ–çš„å®æ•°é€†FFTå®ç°
    function realIFFT(magnitude) {
      // è¿™é‡Œè¿”å›åŸä¿¡å·çš„è¿‘ä¼¼å€¼ï¼Œå› ä¸ºç›¸ä½ä¿¡æ¯ä¸¢å¤±
      return new Float32Array(magnitude);
    }

    // é«˜é€šæ»¤æ³¢å™¨
    function applyHighPassFilter(data, sampleRate, cutoffFreq) {
      const result = new Float32Array(data.length);
      
      // ä½¿ç”¨åŒäºŒé˜¶èŠ‚æ»¤æ³¢å™¨ï¼ˆButterworthï¼‰å®ç°é«˜é€š
      const w0 = 2 * Math.PI * cutoffFreq / sampleRate;
      const sinW0 = Math.sin(w0);
      const cosW0 = Math.cos(w0);
      const alpha = sinW0 / 2 * Math.SQRT2; // Q = 1/sqrt(2) for Butterworth
      
      const b0 = (1 + cosW0) / 2;
      const b1 = -(1 + cosW0);
      const b2 = (1 + cosW0) / 2;
      const a0 = 1 + alpha;
      const a1 = -2 * cosW0;
      const a2 = 1 - alpha;
      
      // å½’ä¸€åŒ–ç³»æ•°
      const norm_b0 = b0 / a0;
      const norm_b1 = b1 / a0;
      const norm_b2 = b2 / a0;
      const norm_a1 = a1 / a0;
      const norm_a2 = a2 / a0;
      
      let x1 = 0, x2 = 0, y1 = 0, y2 = 0;
      
      for (let i = 0; i < data.length; i++) {
        const x = data[i];
        const y = norm_b0 * x + norm_b1 * x1 + norm_b2 * x2 - norm_a1 * y1 - norm_a2 * y2;
        
        result[i] = y;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      
      return result;
    }

    function estimateRecordedSize() {
      if (!recordedChunks.length) return 0;
      return recordedChunks.reduce((total, chunk) => total + chunk.size, 0);
    }

    function checkMemoryPressure() {
      if (!isRecording || !recordingStartTime) return;

      const maxDurationInput = document.getElementById('maxDurationInput');
      const maxDurationSeconds = parseInt(maxDurationInput?.value) || 0;

      if (maxDurationSeconds > 0) {
        const elapsedSeconds = (Date.now() - recordingStartTime) / 1000;
        if (elapsedSeconds >= maxDurationSeconds) {
          console.log(`[Auto Stop] Reached max duration: ${maxDurationSeconds}s`);
          stopRecording(true);
          return;
        }
      }

      if (maxDurationSeconds === 0 && !fileHandle) {
        const estimated = estimateRecordedSize();
        if (estimated > MAX_ESTIMATED_MEMORY_BYTES * 0.9) {
          console.warn(`[Auto Stop] Memory limit reached: ${(estimated / 1024 / 1024).toFixed(1)}MB`);
          stopRecording(true);
        }
      }
    }

    function clearGuardTimer() {
      if (memoryGuardTimer) {
        clearInterval(memoryGuardTimer);
        memoryGuardTimer = null;
      }
    }

    function generateFilename() {
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
      return `recording_${timestamp}.m4a`;
    }

    async function stopAllAudio() {
      clearGuardTimer();

      if (isRecording) {
        await stopRecording(false);
      }

      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }

      if (audioContext) {
        await audioContext.close();
        audioContext = null;
      }

      sourceNode = null;
      analyser = null;
      filters = [];
      isFiltering = false;

      startBtn.disabled = false;
      startBtn.textContent = "å¼€å§‹éŸ³é¢‘";
      stopBtn.disabled = true;
      filterBtn.disabled = true;
      filterBtn.classList.remove('active');
      filterBtn.textContent = "å¯ç”¨æ»¤æ³¢";
      recordBtn.disabled = true;
      recordBtn.classList.remove('active');
      recordBtn.textContent = "å¼€å§‹å½•éŸ³";
      inputSelect.disabled = false;
      log("éŸ³é¢‘å·²å…³é—­");
    }

    async function stopRecording(save = true) {
      if (!isRecording) return;

      isRecording = false;
      recordingStartTime = null;
      clearGuardTimer();

      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      let filename = generateFilename();
      let mimeType = 'audio/mp4';

      if (!MediaRecorder.isTypeSupported('audio/mp4')) {
        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          mimeType = 'audio/webm;codecs=opus';
          filename = filename.replace('.m4a', '.webm');
        } else {
          mimeType = 'audio/webm';
          filename = filename.replace('.m4a', '.webm');
        }
      }

      if (writer) {
        try {
          await writer.close();
          if (save) {
            log(`âœ… å½•éŸ³å·²ä¿å­˜ä¸º: ${filename}`);
          }
        } catch (e) {
          console.warn('Writer close error:', e);
          if (save) log('âš ï¸ æ–‡ä»¶å†™å…¥æœªå®Œæˆ');
        }
        writer = null;
        writableStream = null;
        fileHandle = null;
      }

      if (save && recordedChunks.length > 0 && !fileHandle) {
        const blob = new Blob(recordedChunks, { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        log(`âœ… å½•éŸ³å·²ä¿å­˜ä¸º: ${filename}`);
      }

      recordedChunks = [];
      mediaRecorder = null;
      recordBtn.textContent = "å¼€å§‹å½•éŸ³";
      recordBtn.classList.remove('active');
    }

    startBtn.onclick = async () => {
      try {
        log("æ­£åœ¨å¯åŠ¨éŸ³é¢‘...");

        const constraints = {
          audio: {
            deviceId: currentInputDeviceId === 'default' ? undefined : { exact: currentInputDeviceId },
            sampleRate: 44100,
            channelCount: 1
          }
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        sourceNode = audioContext.createMediaStreamSource(stream);

        buildAudioGraph(false);

        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        startBtn.disabled = true;
        startBtn.textContent = "âœ… éŸ³é¢‘è¿è¡Œä¸­";
        stopBtn.disabled = false;
        filterBtn.disabled = false;
        recordBtn.disabled = false;
        inputSelect.disabled = true;
        log("éŸ³é¢‘å·²å¯åŠ¨ï¼");

        drawFFT();
      } catch (err) {
        log("âŒ éº¦å…‹é£é”™è¯¯: " + err.message);
        alert("æ— æ³•è®¿é—®éº¦å…‹é£: " + err.message);
      }
    };

    stopBtn.onclick = () => {
      stopAllAudio();
    };

    inputSelect.onchange = () => {
      currentInputDeviceId = inputSelect.value || 'default';
      localStorage.setItem('audioInputDeviceId', currentInputDeviceId);
    };

    outputSelect.onchange = () => {
      if (outputSelect.disabled) return;
      currentOutputDeviceId = outputSelect.value || 'default';
      localStorage.setItem('audioOutputDeviceId', currentOutputDeviceId);
    };

    filterBtn.onclick = () => {
      isFiltering = !isFiltering;
      filterBtn.classList.toggle('active', isFiltering);
      filterBtn.textContent = isFiltering ? "å…³é—­æ»¤æ³¢" : "å¯ç”¨æ»¤æ³¢";
      if (audioContext) buildAudioGraph(isFiltering);
    };

    gainSlider.oninput = () => {
      const g = gainSlider.value / 100;
      gainValue.textContent = g.toFixed(1) + 'x';
      if (isFiltering && audioContext) {
        buildAudioGraph(true);
      }
    };

    recordBtn.onclick = async () => {
      if (isRecording) {
        await stopRecording(true);
        return;
      }

      try {
        let useStreamWrite = false;
        let mimeType = 'audio/mp4';

        if ('showSaveFilePicker' in window) {
          try {
            const filename = generateFilename();
            fileHandle = await window.showSaveFilePicker({
              suggestedName: filename,
              types: [{
                description: 'éŸ³é¢‘æ–‡ä»¶',
                accept: {
                  'audio/mp4': ['.m4a'],
                  'audio/webm': ['.webm']
                }
              }]
            });
            useStreamWrite = true;
          } catch (err) {
            if (err.name !== 'AbortError') {
              console.warn('File System Access API error:', err);
            }
            fileHandle = null;
          }
        }

        if (!useStreamWrite) {
          if (!MediaRecorder.isTypeSupported('audio/mp4')) {
            if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
              mimeType = 'audio/webm;codecs=opus';
            } else {
              mimeType = 'audio/webm';
            }
          }
          recordedChunks = [];
        }

        // åˆ›å»ºç”¨äºå½•éŸ³çš„å¤„ç†èŠ‚ç‚¹
        const dest = audioContext.createMediaStreamDestination();
        let recNode = sourceNode;

        if (isFiltering) {
          // ä¸ºå½•éŸ³åˆ›å»ºä¸€ä¸ªå•ç‹¬çš„å¤„ç†é“¾
          const recScriptNode = audioContext.createScriptProcessor(4096, 1, 1);
          
          let recSamplesBuffer = new Float32Array(0);
          const recSampleRate = audioContext.sampleRate;
          
          recScriptNode.onaudioprocess = function(e) {
            const inputData = e.inputBuffer.getChannelData(0);
            const outputData = e.outputBuffer.getChannelData(0);
            
            // å°†æ–°æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
            const newBuffer = new Float32Array(recSamplesBuffer.length + inputData.length);
            newBuffer.set(recSamplesBuffer);
            newBuffer.set(inputData, recSamplesBuffer.length);
            recSamplesBuffer = newBuffer;
            
            // å¦‚æœç¼“å†²åŒºè¶³å¤Ÿå¤§ï¼Œè¿›è¡Œé™å™ªå¤„ç†
            if (recSamplesBuffer.length >= 4096) {
              // å¤„ç†é™å™ª
              let processed = removeHum(recSamplesBuffer.slice(0, 4096), recSampleRate);
              
              // å°†å¤„ç†åçš„æ•°æ®å¤åˆ¶åˆ°è¾“å‡º
              for (let i = 0; i < outputData.length; i++) {
                outputData[i] = processed[i];
              }
              
              // ä¿ç•™æœªå¤„ç†çš„æ•°æ®
              recSamplesBuffer = recSamplesBuffer.slice(4096);
            } else {
              // å¦‚æœç¼“å†²åŒºä¸å¤Ÿå¤§ï¼Œç›´æ¥è¾“å‡ºåŸæ•°æ®
              for (let i = 0; i < outputData.length; i++) {
                outputData[i] = inputData[i];
              }
            }
          };
          
          recNode.connect(recScriptNode);
          recScriptNode.connect(dest);
        } else {
          recNode.connect(dest);
        }

        if (useStreamWrite) {
          if (MediaRecorder.isTypeSupported('audio/mp4')) {
            mimeType = 'audio/mp4';
          } else if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
            mimeType = 'audio/webm;codecs=opus';
          } else {
            mimeType = 'audio/webm';
          }
        }

        mediaRecorder = new MediaRecorder(dest.stream, { mimeType });

        if (useStreamWrite) {
          writableStream = await fileHandle.createWritable();
          writer = writableStream.getWriter();

          mediaRecorder.ondataavailable = async (e) => {
            if (e.data.size > 0 && writer) {
              try {
                const arrayBuffer = await e.data.arrayBuffer();
                await writer.write(arrayBuffer);
              } catch (writeErr) {
                console.error('Write error:', writeErr);
                log('âš ï¸ å†™å…¥æ–‡ä»¶å¤±è´¥');
              }
            }
          };
        } else {
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) recordedChunks.push(e.data);
          };
        }

        mediaRecorder.onerror = (e) => {
          log("âš ï¸ å½•éŸ³é”™è¯¯: " + e.error);
          stopRecording(false);
        };

        mediaRecorder.start(100);

        recordingStartTime = Date.now();
        clearGuardTimer();
        memoryGuardTimer = setInterval(checkMemoryPressure, 500);

        isRecording = true;
        recordBtn.textContent = "åœæ­¢å½•éŸ³";
        recordBtn.classList.add('active');

        const mode = useStreamWrite 
          ? 'ï¼ˆæµå¼å†™å…¥ï¼‰' 
          : 'ï¼ˆå†…å­˜ç¼“å­˜ Â· è‡ªåŠ¨ä¿æŠ¤ï¼‰';
        log("ğŸ™ï¸ å½•éŸ³å·²å¼€å§‹" + mode);

      } catch (err) {
        log("âŒ å½•éŸ³å¯åŠ¨å¤±è´¥: " + err.message);
        console.error(err);
      }
    };

    // ======== ç‚¹å‡»è·å–é¢‘ç‡ ========
    function handleCanvasClick(clientX, clientY) {
      if (!analyser || !audioContext) return;

      const containerRect = document.querySelector('.canvas-container').getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const scrollLeft = document.querySelector('.canvas-container').scrollLeft;

      // è®¡ç®—ç›¸å¯¹äº canvas é€»è¾‘åæ ‡çš„ x
      const x = clientX - canvasRect.left + scrollLeft;
      const plotWidth = LOGICAL_CANVAS_WIDTH - MARGIN_LEFT - MARGIN_RIGHT;

      if (x < MARGIN_LEFT || x > LOGICAL_CANVAS_WIDTH - MARGIN_RIGHT) return;

      const normalizedX = (x - MARGIN_LEFT) / plotWidth;
      const nyquist = audioContext.sampleRate / 2;
      const freq = normalizedX * nyquist;

      log(`ğŸ–±ï¸ å½“å‰é¢‘ç‡: ${freq.toFixed(1)} Hz`);
    }

    canvas.addEventListener('click', (e) => handleCanvasClick(e.clientX, e.clientY));
    canvas.addEventListener('touchend', (e) => {
      if (e.touches.length === 0 && e.changedTouches.length > 0) {
        const touch = e.changedTouches[0];
        handleCanvasClick(touch.clientX, touch.clientY);
        e.preventDefault();
      }
    }, { passive: false });

    // ======== ä¼˜åŒ–åçš„ drawFFT ========
    function drawFFT() {
      if (!analyser) return;
      const bufferLength = analyser.frequencyBinCount; // 512
      const dataArray = new Uint8Array(bufferLength);

      const width = LOGICAL_CANVAS_WIDTH;
      const height = CANVAS_HEIGHT;

      ctx.clearRect(0, 0, width, height);

      const plotWidth = width - MARGIN_LEFT - MARGIN_RIGHT;
      const plotHeight = height - MARGIN_TOP - MARGIN_BOTTOM;

      analyser.getByteFrequencyData(dataArray);

      // ç»˜åˆ¶é¢‘è°±æŸ±çŠ¶å›¾
      const barWidth = plotWidth / bufferLength;
      for (let i = 0; i < bufferLength; i++) {
        const barHeight = (dataArray[i] / 255) * plotHeight;
        ctx.fillStyle = 'cyan';
        const x = MARGIN_LEFT + i * barWidth;
        const y = MARGIN_TOP + (plotHeight - barHeight);
        ctx.fillRect(x, y, barWidth - 1, barHeight);
      }

      // ====== X è½´æ ‡ç­¾ï¼ˆåº•éƒ¨ï¼‰======
      ctx.fillStyle = '#aaa';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      const sampleRate = audioContext ? audioContext.sampleRate : 44100;
      const nyquist = sampleRate / 2;

      // ä½¿ç”¨çº¿æ€§åˆ†å¸ƒçš„åˆç†åˆ»åº¦ï¼ˆè¦†ç›– 0ï½20k+ï¼‰
      const xLabels = [];
      for (let f = 0; f <= 22000; f += 2000) {
        xLabels.push({ freq: f, ratio: f / nyquist });
      }
      // ç¡®ä¿åŒ…å« Nyquist
      if (nyquist > 22000) {
        xLabels.push({ freq: Math.round(nyquist), ratio: 1 });
      }

      xLabels.forEach(label => {
        const x = MARGIN_LEFT + label.ratio * plotWidth;
        if (x >= MARGIN_LEFT && x <= width - MARGIN_RIGHT) {
          ctx.fillText(`${Math.round(label.freq / 1000)}k`, x, height - MARGIN_BOTTOM + 10);
          ctx.beginPath();
          ctx.moveTo(x, height - MARGIN_BOTTOM);
          ctx.lineTo(x, height - MARGIN_BOTTOM + 5);
          ctx.strokeStyle = '#555';
          ctx.stroke();
        }
      });
      ctx.fillText('é¢‘ç‡ (Hz)', width / 2, height - 10);

      // ====== Y è½´æ ‡ç­¾ï¼ˆå·¦ä¾§ï¼‰======
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      const yLabels = [
        { value: 255, ratio: 0 },
        { value: 192, ratio: 0.25 },
        { value: 128, ratio: 0.5 },
        { value: 64,  ratio: 0.75 },
        { value: 0,   ratio: 1 }
      ];
      yLabels.forEach(label => {
        const y = MARGIN_TOP + label.ratio * plotHeight;
        ctx.fillText(label.value.toString(), MARGIN_LEFT - 10, y);
        ctx.beginPath();
        ctx.moveTo(MARGIN_LEFT - 5, y);
        ctx.lineTo(MARGIN_LEFT + 5, y);
        ctx.strokeStyle = '#555';
        ctx.stroke();
      });

      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.fillText('å¹…åº¦', 0, 0);
      ctx.restore();

      requestAnimationFrame(drawFFT);
    }

    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(stream => {
        stream.getTracks().forEach(track => track.stop());
        enumerateDevices();
      })
      .catch(() => enumerateDevices());

    navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);
  </script>
</body>
</html>



